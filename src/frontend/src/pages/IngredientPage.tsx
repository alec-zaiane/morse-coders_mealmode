// Semi-generated by Sonnet 4.6, edited and modified/fixed by hand
import { useState, useEffect, useMemo, useCallback } from 'react';
import { useParams } from 'react-router-dom';
import { Refrigerator, Plus, Trash2, RefreshCw, AlertTriangle } from 'lucide-react';
import { useQueryClient } from '@tanstack/react-query';
import {
  useIngredientsRetrieve,
  useIngredientsPartialUpdate,
  useRecipesList,
  useIngredientStoreCreate,
  useIngredientStorePartialUpdate,
  useScrapersCreate,
  useScrapersRefreshCreate,
  useSourcesCreate,
  useSourcesDestroy,
  getIngredientsRetrieveQueryKey,
  getRecipesListQueryKey,
  getSourcesListQueryKey,
  QuantityUnitEnum,
} from '../api/mealmodeAPI';
import type { Ingredient, OnHandIngredient } from '../api/mealmodeAPI';
import { Button } from '../components/ui/button';
import { Input } from '../components/ui/input';
import { NutritionLabel } from '../components/nutritionLabel';
import { RecipeCard } from '../components/recipecard';
import { multiplyNutritionStats } from '../utils/calculations';
import { fetchAllPages } from '../utils/api';
import { Card } from '../components/ui/card';
import { Breadcrumbs } from '../components/Breadcrumbs';

function CostForm({
  ingredient,
  ingredientId,
  onSaved,
}: {
  readonly ingredient: Ingredient;
  readonly ingredientId: number;
  readonly onSaved: () => void;
}) {
  const queryClient = useQueryClient();
  const [estimatedCost, setEstimatedCost] = useState<string>(
    ingredient.estimated_cost == null ? '' : String(ingredient.estimated_cost)
  );
  const [editingCost, setEditingCost] = useState(false);
  const [showAddSource, setShowAddSource] = useState(false);
  const [newSourceUrl, setNewSourceUrl] = useState('');
  const [newSourceQuantity, setNewSourceQuantity] = useState('1');
  const [newSourceUnit, setNewSourceUnit] = useState<QuantityUnitEnum>(QuantityUnitEnum.kg);
  const [deleteConfirmId, setDeleteConfirmId] = useState<number | null>(null);

  useEffect(() => {
    setEstimatedCost(ingredient.estimated_cost == null ? '' : String(ingredient.estimated_cost));
  }, [ingredient.estimated_cost]);

  const invalidate = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: getIngredientsRetrieveQueryKey(ingredientId) });
    onSaved();
  }, [queryClient, ingredientId, onSaved]);

  const invalidateAll = useCallback(() => {
    invalidate();
    queryClient.invalidateQueries({ queryKey: getRecipesListQueryKey() });
    queryClient.invalidateQueries({ queryKey: getSourcesListQueryKey() });
  }, [invalidate, queryClient]);

  const patchIngredient = useIngredientsPartialUpdate({
    mutation: { onSuccess: () => { setEditingCost(false); invalidate(); } },
  });
  const createScraper = useScrapersCreate();
  const createSource = useSourcesCreate({
    mutation: {
      onSuccess: () => {
        setShowAddSource(false);
        setNewSourceUrl('');
        setNewSourceQuantity('1');
        invalidateAll();
      },
    },
  });
  const destroySource = useSourcesDestroy({
    mutation: { onSuccess: () => { setDeleteConfirmId(null); invalidateAll(); } },
  });

  const refreshScraper = useScrapersRefreshCreate({
    mutation: {
      onSuccess: () => {
        invalidateAll();
      },
    },
  });

  const handleRefresh = () => {
    if (ingredient.scraper?.id != null) {
      refreshScraper.mutate({ id: ingredient.scraper.id, data: {} as never });
    }
  };

  const sources = ingredient.scraper?.sources ?? [];
  const unit = ingredient.nutrition_stats?.base_unit ?? 'unit';

  const handleSaveCost = () => {
    const cost = estimatedCost.trim() === '' ? null : Number.parseFloat(estimatedCost);
    patchIngredient.mutate({ id: ingredientId, data: { estimated_cost: cost } });
  };

  const handleAddSource = () => {
    if (!newSourceUrl.trim()) return;
    const qty = Number.parseFloat(newSourceQuantity) || 1;
    const doCreate = (scraperId: number) => {
      createSource.mutate({
        data: { scraper: scraperId, url: newSourceUrl.trim().split('?')[0], quantity: qty, quantity_unit: newSourceUnit },
      });
    };
    if (ingredient.scraper?.id != null) {
      doCreate(ingredient.scraper.id);
    } else {
      createScraper.mutate(
        { data: { ingredient: ingredientId } },
        {
          onSuccess: (resp) => {
            const scraperData = (resp as { data?: { id: number } }).data;
            if (scraperData?.id != null) doCreate(scraperData.id);
          },
        }
      );
    }
  };

  const isAddPending = createSource.isPending || createScraper.isPending;

  return (
    <Card className="p-4 space-y-4">
      <h3 className="font-semibold">Cost</h3>

      {/* Best scraped price */}
      {ingredient.scraper && (
        <div className="flex items-center justify-between rounded-md bg-palette-cream/50 border border-palette-mist px-3 py-2">
          <div>
            <p className="text-xs text-palette-slate mb-0.5">Best found price</p>
            {ingredient.scraper.cached_price != null ? (
              <p className="text-sm font-semibold text-palette-taupe">
                ${ingredient.scraper.cached_price.toFixed(2)}&nbsp;/&nbsp;{unit}
                {ingredient.scraper.cached_source?.url && (
                  <a
                    href={ingredient.scraper.cached_source.url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="ml-2 text-xs font-normal text-palette-slate hover:underline truncate max-w-[200px] inline-block align-middle"
                  >
                    {new URL(ingredient.scraper.cached_source.url).hostname}
                  </a>
                )}
              </p>
            ) : (
              <p className="text-sm text-palette-slate">No price scraped yet</p>
            )}
          </div>
          <Button
            size="sm"
            variant="outline"
            onClick={handleRefresh}
            disabled={refreshScraper.isPending || sources.length === 0}
            className="shrink-0"
          >
            <RefreshCw className={`w-3 h-3 mr-1 ${refreshScraper.isPending ? 'animate-spin' : ''}`} />
            {refreshScraper.isPending ? 'Fetching…' : 'Refresh'}
          </Button>
        </div>
      )}

      {/* Estimated cost */}
      <div className="flex items-center gap-2">
        <label className="w-36 text-sm shrink-0">Estimated cost</label>
        {editingCost ? (
          <div className="flex items-center gap-2 flex-1">
            <Input
              type="number"
              min={0}
              step="any"
              value={estimatedCost}
              onChange={e => setEstimatedCost(e.target.value)}
              className="flex-1"
              placeholder="e.g. 3.50"
              autoFocus
            />
            <span className="text-sm text-palette-slate shrink-0">/ {unit}</span>
          </div>
        ) : (
          <span className="text-sm font-medium flex-1">
            {ingredient.estimated_cost == null
              ? '—'
              : `$${ingredient.estimated_cost.toFixed(2)} / ${unit}`}
          </span>
        )}
        {editingCost ? (
          <div className="flex gap-1 shrink-0">
            <Button size="sm" onClick={handleSaveCost} disabled={patchIngredient.isPending}>
              {patchIngredient.isPending ? 'Saving…' : 'Save'}
            </Button>
            <Button size="sm" variant="outline" onClick={() => {
              setEditingCost(false);
              setEstimatedCost(ingredient.estimated_cost == null ? '' : String(ingredient.estimated_cost));
            }}>
              Cancel
            </Button>
          </div>
        ) : (
          <Button size="sm" variant="outline" className="shrink-0" onClick={() => setEditingCost(true)}>Edit</Button>
        )}
      </div>

      {/* Price sources */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <span className="text-sm font-medium">Price sources</span>
          <Button size="sm" variant="outline" onClick={() => setShowAddSource(v => !v)}>
            <Plus className="w-3 h-3 mr-1" />
            Add source
          </Button>
        </div>

        {showAddSource && (
          <div className="p-3 border border-palette-mist rounded-md bg-palette-cream/30 space-y-2">
            <Input
              placeholder="URL (e.g. https://store.com/product)"
              value={newSourceUrl}
              onChange={e => setNewSourceUrl(e.target.value)}
              className="h-8 text-sm"
              autoFocus
            />
            <div className="flex gap-2">
              <Input
                type="number"
                min={0}
                step="any"
                placeholder="Quantity"
                value={newSourceQuantity}
                onChange={e => setNewSourceQuantity(e.target.value)}
                className="h-8 text-sm flex-1"
              />
              <select
                value={newSourceUnit}
                onChange={e => setNewSourceUnit(e.target.value as QuantityUnitEnum)}
                className="h-8 text-sm border border-input rounded px-2 bg-background"
              >
                {Object.values(QuantityUnitEnum).map(u => (
                  <option key={u} value={u}>{u}</option>
                ))}
              </select>
            </div>
            <div className="flex gap-2">
              <Button
                size="sm"
                onClick={handleAddSource}
                disabled={!newSourceUrl.trim() || isAddPending}
              >
                {isAddPending ? 'Saving…' : 'Add'}
              </Button>
              <Button size="sm" variant="outline" onClick={() => { setShowAddSource(false); setNewSourceUrl(''); }}>Cancel</Button>
            </div>
          </div>
        )}

        {sources.length === 0 ? (
          <p className="text-sm text-palette-slate">No sources added yet.</p>
        ) : (
          <ul className="space-y-2">
            {sources.map(src => (
              <li key={src.id} className={`text-sm border rounded-md p-2 flex items-center gap-2 ${src.cached_error ? 'border-amber-400 bg-amber-50' : 'border-palette-mist'}`}>
                {deleteConfirmId === src.id ? (
                  <>
                    <span className="flex-1 text-red-600 text-xs">Remove this source?</span>
                    <Button
                      size="sm" variant="ghost"
                      className="h-6 px-2 text-xs text-red-600 hover:bg-red-50"
                      onClick={() => destroySource.mutate({ id: src.id })}
                    >Yes</Button>
                    <Button size="sm" variant="ghost" className="h-6 px-2 text-xs" onClick={() => setDeleteConfirmId(null)}>No</Button>
                  </>
                ) : (
                  <>
                    <div className="flex-1 min-w-0">
                      <a
                        href={src.url} target="_blank" rel="noopener noreferrer"
                        className="text-palette-taupe hover:underline truncate block text-xs"
                      >
                        {src.url}
                      </a>
                      <span className="text-palette-slate text-xs">
                        {src.quantity} {src.quantity_unit}
                        {src.cached_price == null ? '' : ` · $${src.cached_price.toFixed(2)} / ${unit}`}
                      </span>
                      {src.cached_error && (
                        <div className="flex items-center gap-1 mt-1 text-amber-700 text-xs">
                          <AlertTriangle className="w-3 h-3 shrink-0" />
                          <span>{src.cached_error}</span>
                        </div>
                      )}
                    </div>
                    <button
                      type="button"
                      className="text-palette-slate hover:text-red-500 shrink-0 p-1"
                      onClick={() => setDeleteConfirmId(src.id)}
                      aria-label="Delete source"
                    >
                      <Trash2 className="w-3.5 h-3.5" />
                    </button>
                  </>
                )}
              </li>
            ))}
          </ul>
        )}
      </div>
    </Card>
  );
}

type OnHandFormValues = {
  quantity: string;
  desired_quantity: string;
  warning_quantity: string;
  notes: string;
};

function ingredientToFormValues(ingredient: Ingredient | null | undefined): OnHandFormValues {
  return {
    quantity: ingredient?.on_hand?.quantity == null ? '' : String(ingredient.on_hand?.quantity),
    desired_quantity: ingredient?.on_hand?.desired_quantity == null ? '' : String(ingredient.on_hand?.desired_quantity),
    warning_quantity: ingredient?.on_hand?.warning_quantity == null ? '' : String(ingredient.on_hand?.warning_quantity),
    notes: ingredient?.on_hand?.notes ?? '',
  };
}

function parseOpt(v: string): number | null {
  const n = Number.parseFloat(v);
  return Number.isNaN(n) ? null : n;
}

function OnHandForm({
  ingredient,
  ingredientId,
  existing,
  onSaved,
}: {
  readonly ingredient: Ingredient;
  readonly ingredientId: number;
  readonly existing: OnHandIngredient | null | undefined;
  readonly onSaved: () => void;
}) {
  const [values, setValues] = useState<OnHandFormValues>(() => ingredientToFormValues(ingredient));
  const [editing, setEditing] = useState(!existing);

  useEffect(() => {
    setValues(ingredientToFormValues(ingredient));
    setEditing(!existing);
  }, [ingredient, existing]);

  const createMutation = useIngredientStoreCreate();
  const patchMutation = useIngredientStorePartialUpdate();
  const patchIngredient = useIngredientsPartialUpdate();
  const queryClient = useQueryClient();
  const isPending = createMutation.isPending || patchMutation.isPending || patchIngredient.isPending;

  const handleSave = useCallback(() => {
    const onHandPayload = {
      quantity: parseOpt(values.quantity),
      desired_quantity: parseOpt(values.desired_quantity),
      warning_quantity: parseOpt(values.warning_quantity),
      notes: values.notes,
    };
    if (existing) {
      patchMutation.mutate({ id: existing.id, data: onHandPayload }, { onSuccess: () => { setEditing(false); onSaved(); } });
    } else {
      createMutation.mutate({ data: { ...onHandPayload, ingredient: ingredientId } }, { onSuccess: () => { setEditing(false); onSaved(); } });
    }
  }, [values, existing, ingredientId, onSaved, createMutation, patchMutation, patchIngredient, queryClient]);

  function field(label: string, key: keyof OnHandFormValues, unit?: string) {
    return (
      <div className="flex items-center gap-2">
        <label className="w-36 text-sm shrink-0">{label}</label>
        {editing ? (
          <div className="flex items-center gap-2 flex-1">
            <Input
              type="number"
              min={0}
              value={values[key]}
              onChange={e => setValues(v => ({ ...v, [key]: e.target.value }))}
              className="flex-1"
            />
            <div>{unit}</div>
          </div>
        ) : (
          <span className="text-sm font-medium">{values[key] === '' ? '—' : `${values[key]}${unit ?? ''}`}</span>
        )}
      </div>
    );
  }

  return (
    <Card className="p-4 space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold flex items-center gap-2">
          <Refrigerator className="w-4 h-4" /> On-Hand
        </h3>
        {!editing && (
          <Button variant="outline" size="sm" onClick={() => setEditing(true)}>Edit</Button>
        )}
      </div>
      {field('Quantity on hand', 'quantity', ingredient.nutrition_stats?.base_unit)}
      {field('Desired quantity', 'desired_quantity', ingredient.nutrition_stats?.base_unit)}
      {field('Warning below', 'warning_quantity', ingredient.nutrition_stats?.base_unit)}
      <div className="flex items-center gap-2">
        <label htmlFor="on-hand-notes" className="w-36 text-sm shrink-0">Notes</label>
        {editing ? (
          <Input
            id="on-hand-notes"
            value={values.notes}
            onChange={e => setValues(v => ({ ...v, notes: e.target.value }))}
            className="flex-1"
          />
        ) : (
          <span className="text-sm font-medium">{values.notes || '—'}</span>
        )}
      </div>
      {editing && (
        <div className="flex gap-2 pt-1">
          <Button size="sm" onClick={handleSave} disabled={isPending}>
            {isPending ? 'Saving…' : 'Save'}
          </Button>
          {existing && (
            <Button size="sm" variant="outline" onClick={() => { setEditing(false); setValues(ingredientToFormValues(ingredient)); }}>
              Cancel
            </Button>
          )}
        </div>
      )}
    </Card>
  );
}

export function IngredientPage() {
  const { id } = useParams<{ id: string }>();
  const queryClient = useQueryClient();
  const numericId = id == null ? Number.NaN : Number(id);
  const validId = !Number.isNaN(numericId) && numericId > 0;

  const { data, isLoading, isError } = useIngredientsRetrieve(
    validId ? numericId : 0,
    { query: { enabled: validId } }
  );
  const ingredient = data?.data;

  const { data: recipesData } = useRecipesList(undefined, { query: { enabled: validId } });
  const [allRecipes, setAllRecipes] = useState<NonNullable<typeof recipesData>['data']['results']>([]);

  useEffect(() => {
    if (recipesData) {
      fetchAllPages<NonNullable<typeof recipesData>['data']['results'][number]>(recipesData)
        .then(r => setAllRecipes(r));
    }
  }, [recipesData]);

  const usedInRecipes = useMemo(
    () => allRecipes.filter(r => r.ingredients_list.some(ri => ri.ingredient.id === numericId)),
    [allRecipes, numericId]
  );

  function invalidateIngredient() {
    queryClient.invalidateQueries({ queryKey: getIngredientsRetrieveQueryKey(numericId) });
  }

  if (!validId) {
    return (
      <div className="space-y-4">
        <Breadcrumbs items={[{ label: 'Ingredients', href: '/ingredients' }]} />
        <div className="text-center py-12">
          <p className="text-palette-taupe">Invalid ingredient</p>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return <div className="text-center py-12 text-palette-slate">Loading…</div>;
  }

  if (isError || !ingredient) {
    return (
      <div className="space-y-4">
        <Breadcrumbs items={[{ label: 'Ingredients', href: '/ingredients' }]} />
        <div className="text-center py-12">
          <p className="text-palette-taupe">Ingredient not found</p>
        </div>
      </div>
    );
  }

  const stats = ingredient.nutrition_stats;
  const unit = stats?.base_unit ?? 'unit';
  const aggregatedStats = stats ? multiplyNutritionStats(stats, 1) : null;

  return (
    <div className="space-y-6">
      <Breadcrumbs
        items={[
          { label: 'Ingredients', href: '/ingredients' },
          { label: ingredient.name },
        ]}
      />
      <h2 className="text-2xl font-semibold text-palette-taupe">{ingredient.name}</h2>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Left column */}
        <div className="space-y-4">
          <OnHandForm
            ingredient={ingredient}
            ingredientId={numericId}
            existing={ingredient.on_hand}
            onSaved={invalidateIngredient}
          />
          <h3 className="font-semibold text-lg">Used in recipes</h3>
          {usedInRecipes.length === 0 ? (
            <p className="text-sm text-palette-slate">Not used in any recipes.</p>
          ) : (
            <div className="grid grid-cols-1 gap-4">
              {usedInRecipes.map(recipe => (
                <RecipeCard key={recipe.id} recipe={recipe} />
              ))}
            </div>
          )}
        </div>

        {/* Right column */}
        <div className="space-y-4">
          {aggregatedStats && (
            <Card className="p-4">
              <NutritionLabel nutritionStats={aggregatedStats} per_unit={unit} />
            </Card>
          )}
          <CostForm
            ingredient={ingredient}
            ingredientId={numericId}
            onSaved={invalidateIngredient}
          />
        </div>
      </div>
    </div>
  );
}
