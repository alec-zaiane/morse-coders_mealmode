// Semi-generated by Sonnet 4.6, edited and modified/fixed by hand
import { useState, useEffect, useMemo, useCallback } from 'react';
import { useParams } from 'react-router-dom';
import { Refrigerator, Plus, Trash2, RefreshCw, AlertTriangle } from 'lucide-react';
import { useQueryClient } from '@tanstack/react-query';
import {
  useIngredientsRetrieve,
  useIngredientsPartialUpdate,
  useRecipesList,
  useIngredientStoreCreate,
  useIngredientStorePartialUpdate,
  useScrapersCreate,
  useScrapersRefreshCreate,
  useSourcesCreate,
  useSourcesDestroy,
  getIngredientsRetrieveQueryKey,
  QuantityUnitEnum,
} from '../api/mealmodeAPI';
import type { Ingredient, OnHandIngredient } from '../api/mealmodeAPI';
import { Button } from '../components/ui/button';
import { Input } from '../components/ui/input';
import { NutritionLabel } from '../components/nutritionLabel';
import { RecipeCard } from '../components/recipecard';
import { multiplyNutritionStats } from '../utils/calculations';
import { fetchAllPages } from '../utils/api';
import { Card } from '../components/ui/card';
import { Breadcrumbs } from '../components/Breadcrumbs';

function getApiErrorMessage(err: unknown, fallback: string): string {
  const data = (err as { response?: { data?: unknown } })?.response?.data;
  if (typeof data === 'string') return data;
  if (!data || typeof data !== 'object') return fallback;

  const maybeDetail = (data as { detail?: unknown }).detail;
  if (typeof maybeDetail === 'string') return maybeDetail;

  const entries = Object.entries(data as Record<string, unknown>);
  if (entries.length === 0) return fallback;

  const formatted = entries
    .map(([field, value]) => {
      if (Array.isArray(value)) return `${field}: ${value.map(String).join(', ')}`;
      if (typeof value === 'string') return `${field}: ${value}`;
      return null;
    })
    .filter((msg): msg is string => msg != null);

  return formatted.length > 0 ? formatted.join(' | ') : fallback;
}

function CostForm({
  ingredient,
  ingredientId,
  onSaved,
}: {
  readonly ingredient: Ingredient;
  readonly ingredientId: number;
  readonly onSaved: () => void;
}) {
  const queryClient = useQueryClient();
  const [estimatedCost, setEstimatedCost] = useState<string>(
    ingredient.estimated_cost == null ? '' : String(ingredient.estimated_cost)
  );
  const [editingCost, setEditingCost] = useState(false);
  const [showAddSource, setShowAddSource] = useState(false);
  const [newSourceUrl, setNewSourceUrl] = useState('');
  const [newSourceQuantity, setNewSourceQuantity] = useState('1');
  const [newSourceUnit, setNewSourceUnit] = useState<QuantityUnitEnum>(QuantityUnitEnum.kg);
  const [sourceErrorMessage, setSourceErrorMessage] = useState<string | null>(null);
  const [optimisticallyRemovedSourceIds, setOptimisticallyRemovedSourceIds] = useState<Set<number>>(new Set());

  useEffect(() => {
    setEstimatedCost(ingredient.estimated_cost == null ? '' : String(ingredient.estimated_cost));
  }, [ingredient.estimated_cost]);

  const invalidate = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: getIngredientsRetrieveQueryKey(ingredientId) });
    onSaved();
  }, [queryClient, ingredientId, onSaved]);

  const patchIngredient = useIngredientsPartialUpdate({
    mutation: { onSuccess: () => { setEditingCost(false); invalidate(); } },
  });
  const createScraper = useScrapersCreate();
  const createSource = useSourcesCreate({
    mutation: {
      onSuccess: () => {
        setSourceErrorMessage(null);
        setShowAddSource(false);
        setNewSourceUrl('');
        setNewSourceQuantity('1');
        setOptimisticallyRemovedSourceIds(new Set());
        invalidate();
      },
      onError: (err: unknown) => {
        setSourceErrorMessage(getApiErrorMessage(err, 'Failed to add source.'));
      },
    },
  });
  const destroySource = useSourcesDestroy({
    mutation: {
      onSuccess: () => {
        setSourceErrorMessage(null);
        setOptimisticallyRemovedSourceIds(new Set());
        invalidate();
      },
      onError: (err: unknown) => {
        setSourceErrorMessage(getApiErrorMessage(err, 'Failed to delete source.'));
      },
    },
  });

  const refreshScraper = useScrapersRefreshCreate({
    mutation: { onSuccess: invalidate },
  });

  const handleRefresh = () => {
    if (ingredient.scraper?.id != null) {
      refreshScraper.mutate({ id: ingredient.scraper.id, data: {} as never });
    }
  };

  const sources = (ingredient.scraper?.sources ?? []).filter(
    (src) => !optimisticallyRemovedSourceIds.has(src.id)
  );
  const unit = ingredient.nutrition_stats?.base_unit ?? 'unit';

  const handleSaveCost = () => {
    const cost = estimatedCost.trim() === '' ? null : Number.parseFloat(estimatedCost);
    patchIngredient.mutate({ id: ingredientId, data: { estimated_cost: cost } });
  };

  const handleAddSource = () => {
    if (!newSourceUrl.trim()) return;
    let parsedUrl: URL;
    try {
      parsedUrl = new URL(newSourceUrl.trim());
    } catch {
      setSourceErrorMessage('Enter a valid URL starting with http:// or https://');
      return;
    }
    if (!['http:', 'https:'].includes(parsedUrl.protocol)) {
      setSourceErrorMessage('URL must start with http:// or https://');
      return;
    }
    if (newSourceUrl.trim().length > 500) {
      setSourceErrorMessage('URL is too long. Maximum length is 500 characters.');
      return;
    }
    setSourceErrorMessage(null);
    const qty = Number.parseFloat(newSourceQuantity) || 1;
    const doCreate = (scraperId: number) => {
      createSource.mutate({
        data: { scraper: scraperId, url: parsedUrl.toString(), quantity: qty, quantity_unit: newSourceUnit },
      });
    };
    if (ingredient.scraper?.id != null) {
      doCreate(ingredient.scraper.id);
    } else {
      createScraper.mutate(
        { data: { ingredient: ingredientId } },
        {
          onSuccess: (resp) => {
            const scraperData = (resp as { data?: { id: number } }).data;
            if (scraperData?.id != null) doCreate(scraperData.id);
          },
        }
      );
    }
  };

  const isAddPending = createSource.isPending || createScraper.isPending;
  const isDeletePending = destroySource.isPending;

  const handleDeleteSource = (sourceId: number) => {
    setSourceErrorMessage(null);
    setOptimisticallyRemovedSourceIds((prev) => new Set(prev).add(sourceId));
    destroySource.mutate(
      { id: sourceId },
      {
        onError: () => {
          setOptimisticallyRemovedSourceIds((prev) => {
            const next = new Set(prev);
            next.delete(sourceId);
            return next;
          });
        },
      }
    );
  };

  return (
    <Card className="h-full p-4 space-y-4">
      <h3 className="font-semibold">Cost</h3>

      {/* Best scraped price */}
      {ingredient.scraper && (
        <div className="flex items-center justify-between rounded-md bg-palette-background/50 border border-palette-border px-3 py-2">
          <div>
            <p className="text-xs text-palette-textMuted mb-0.5">Best found price</p>
            {ingredient.scraper.cached_price != null ? (
              <p className="text-sm font-semibold text-palette-text">
                ${ingredient.scraper.cached_price.toFixed(2)}&nbsp;/&nbsp;{unit}
                {ingredient.scraper.cached_source?.url && (
                  <a
                    href={ingredient.scraper.cached_source.url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="ml-2 text-xs font-normal text-palette-textMuted hover:underline truncate max-w-[200px] inline-block align-middle"
                  >
                    {new URL(ingredient.scraper.cached_source.url).hostname}
                  </a>
                )}
              </p>
            ) : (
              <p className="text-sm text-palette-textMuted">No price scraped yet</p>
            )}
          </div>
          <Button
            size="sm"
            variant="outline"
            onClick={handleRefresh}
            disabled={refreshScraper.isPending || sources.length === 0}
            className="shrink-0"
          >
            <RefreshCw className={`w-3 h-3 mr-1 ${refreshScraper.isPending ? 'animate-spin' : ''}`} />
            {refreshScraper.isPending ? 'Fetching…' : 'Refresh'}
          </Button>
        </div>
      )}

      {/* Estimated cost */}
      <div className="flex items-center gap-2">
        <label className="w-36 text-sm shrink-0">Estimated cost</label>
        {editingCost ? (
          <div className="flex items-center gap-2 flex-1">
            <Input
              type="number"
              min={0}
              step="any"
              value={estimatedCost}
              onChange={e => setEstimatedCost(e.target.value)}
              className="flex-1"
              placeholder="e.g. 3.50"
              autoFocus
            />
            <span className="text-sm text-palette-textMuted shrink-0">/ {unit}</span>
          </div>
        ) : (
          <span className="text-sm font-medium flex-1">
            {ingredient.estimated_cost == null
              ? '—'
              : `$${ingredient.estimated_cost.toFixed(2)} / ${unit}`}
          </span>
        )}
        {editingCost ? (
          <div className="flex gap-1 shrink-0">
            <Button size="sm" onClick={handleSaveCost} disabled={patchIngredient.isPending}>
              {patchIngredient.isPending ? 'Saving…' : 'Save'}
            </Button>
            <Button size="sm" variant="outline" onClick={() => {
              setEditingCost(false);
              setEstimatedCost(ingredient.estimated_cost == null ? '' : String(ingredient.estimated_cost));
            }}>
              Cancel
            </Button>
          </div>
        ) : (
          <Button size="sm" variant="outline" className="shrink-0" onClick={() => setEditingCost(true)}>Edit</Button>
        )}
      </div>

      {/* Price sources */}
      <div className="space-y-2">
        <div className="flex items-center justify-between">
          <span className="text-sm font-medium">Price sources</span>
          <Button size="sm" variant="outline" onClick={() => setShowAddSource(v => !v)}>
            <Plus className="w-3 h-3 mr-1" />
            Add source
          </Button>
        </div>

        {showAddSource && (
          <div className="p-3 border border-palette-border rounded-md bg-palette-background/30 space-y-2">
            <Input
              placeholder="URL (e.g. https://store.com/product)"
              value={newSourceUrl}
              onChange={e => setNewSourceUrl(e.target.value)}
              className="h-8 text-sm"
              autoFocus
            />
            <div className="flex gap-2">
              <Input
                type="number"
                min={0}
                step="any"
                placeholder="Quantity"
                value={newSourceQuantity}
                onChange={e => setNewSourceQuantity(e.target.value)}
                className="h-8 text-sm flex-1"
              />
              <select
                value={newSourceUnit}
                onChange={e => setNewSourceUnit(e.target.value as QuantityUnitEnum)}
                className="h-8 text-sm border border-input rounded px-2 bg-background"
              >
                {Object.values(QuantityUnitEnum).map(u => (
                  <option key={u} value={u}>{u}</option>
                ))}
              </select>
            </div>
            <div className="flex gap-2">
              <Button
                size="sm"
                onClick={handleAddSource}
                disabled={!newSourceUrl.trim() || isAddPending}
              >
                {isAddPending ? 'Saving…' : 'Add'}
              </Button>
              <Button size="sm" variant="outline" onClick={() => { setShowAddSource(false); setNewSourceUrl(''); }}>Cancel</Button>
            </div>
          </div>
        )}
        {sourceErrorMessage && (
          <p className="text-xs text-red-600">{sourceErrorMessage}</p>
        )}

        {sources.length === 0 ? (
          <p className="text-sm text-palette-textMuted">No sources added yet.</p>
        ) : (
          <ul className="space-y-2">
            {sources.map((src) => (
              <li
                key={src.id}
                className={`text-sm border rounded-md p-2 flex items-center gap-2 ${
                  src.cached_error
                    ? 'border-yellow-300 bg-yellow-50'
                    : 'border-palette-border'
                }`}
              >
                <>
                  <div className="flex-1 min-w-0">
                    <a
                      href={src.url} target="_blank" rel="noopener noreferrer"
                      className="text-palette-text hover:underline truncate block text-xs"
                    >
                      {src.url}
                    </a>
                    <span className="text-palette-textMuted text-xs">
                      {src.quantity} {src.quantity_unit}
                      {src.cached_price == null ? '' : ` · $${src.cached_price.toFixed(2)} / ${unit}`}
                    </span>
                    {src.cached_error && (
                      <div className="mt-1 flex items-start gap-1.5 text-yellow-900">
                        <AlertTriangle className="w-3.5 h-3.5 shrink-0 mt-0.5" />
                        <span className="text-xs font-medium break-words">
                          {src.cached_error}
                        </span>
                      </div>
                    )}
                  </div>
                  <button
                    type="button"
                    className="text-palette-textMuted hover:text-red-500 shrink-0 p-1 disabled:opacity-50"
                    onClick={() => handleDeleteSource(src.id)}
                    aria-label="Delete source"
                    disabled={isDeletePending}
                  >
                    <Trash2 className="w-3.5 h-3.5" />
                  </button>
                </>
              </li>
            ))}
          </ul>
        )}
      </div>
    </Card>
  );
}

type OnHandFormValues = {
  quantity: string;
  desired_quantity: string;
  warning_quantity: string;
  notes: string;
};

function ingredientToFormValues(ingredient: Ingredient | null | undefined): OnHandFormValues {
  return {
    quantity: ingredient?.on_hand?.quantity == null ? '' : String(ingredient.on_hand?.quantity),
    desired_quantity: ingredient?.on_hand?.desired_quantity == null ? '' : String(ingredient.on_hand?.desired_quantity),
    warning_quantity: ingredient?.on_hand?.warning_quantity == null ? '' : String(ingredient.on_hand?.warning_quantity),
    notes: ingredient?.on_hand?.notes ?? '',
  };
}

function parseOpt(v: string): number | null {
  const n = Number.parseFloat(v);
  return Number.isNaN(n) ? null : n;
}

function OnHandForm({
  ingredient,
  ingredientId,
  existing,
  onSaved,
}: {
  readonly ingredient: Ingredient;
  readonly ingredientId: number;
  readonly existing: OnHandIngredient | null | undefined;
  readonly onSaved: () => void;
}) {
  const [values, setValues] = useState<OnHandFormValues>(() => ingredientToFormValues(ingredient));
  const [editing, setEditing] = useState(!existing);

  useEffect(() => {
    setValues(ingredientToFormValues(ingredient));
    setEditing(!existing);
  }, [ingredient, existing]);

  const createMutation = useIngredientStoreCreate();
  const patchMutation = useIngredientStorePartialUpdate();
  const patchIngredient = useIngredientsPartialUpdate();
  const queryClient = useQueryClient();
  const isPending = createMutation.isPending || patchMutation.isPending || patchIngredient.isPending;

  const handleSave = useCallback(() => {
    const onHandPayload = {
      quantity: parseOpt(values.quantity),
      desired_quantity: parseOpt(values.desired_quantity),
      warning_quantity: parseOpt(values.warning_quantity),
      notes: values.notes,
    };
    if (existing) {
      patchMutation.mutate({ id: existing.id, data: onHandPayload }, { onSuccess: () => { setEditing(false); onSaved(); } });
    } else {
      createMutation.mutate({ data: { ...onHandPayload, ingredient: ingredientId } }, { onSuccess: () => { setEditing(false); onSaved(); } });
    }
  }, [values, existing, ingredientId, onSaved, createMutation, patchMutation, patchIngredient, queryClient]);

  function field(label: string, key: keyof OnHandFormValues, unit?: string) {
    return (
      <div className="flex items-center gap-2">
        <label className="w-36 text-sm shrink-0">{label}</label>
        {editing ? (
          <div className="flex items-center gap-2 flex-1">
            <Input
              type="number"
              min={0}
              value={values[key]}
              onChange={e => setValues(v => ({ ...v, [key]: e.target.value }))}
              className="flex-1"
            />
            <div>{unit}</div>
          </div>
        ) : (
          <span className="text-sm font-medium">{values[key] === '' ? '—' : `${values[key]}${unit ?? ''}`}</span>
        )}
      </div>
    );
  }

  return (
    <Card className="h-full p-4 space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold flex items-center gap-2">
          <Refrigerator className="w-4 h-4" /> On-Hand
        </h3>
        {!editing && (
          <Button variant="outline" size="sm" onClick={() => setEditing(true)}>Edit</Button>
        )}
      </div>
      {field('Quantity on hand', 'quantity', ingredient.nutrition_stats?.base_unit)}
      {field('Desired quantity', 'desired_quantity', ingredient.nutrition_stats?.base_unit)}
      {field('Warning below', 'warning_quantity', ingredient.nutrition_stats?.base_unit)}
      <div className="flex items-center gap-2">
        <label htmlFor="on-hand-notes" className="w-36 text-sm shrink-0">Notes</label>
        {editing ? (
          <Input
            id="on-hand-notes"
            value={values.notes}
            onChange={e => setValues(v => ({ ...v, notes: e.target.value }))}
            className="flex-1"
          />
        ) : (
          <span className="text-sm font-medium">{values.notes || '—'}</span>
        )}
      </div>
      {editing && (
        <div className="flex gap-2 pt-1">
          <Button size="sm" onClick={handleSave} disabled={isPending}>
            {isPending ? 'Saving…' : 'Save'}
          </Button>
          {existing && (
            <Button size="sm" variant="outline" onClick={() => { setEditing(false); setValues(ingredientToFormValues(ingredient)); }}>
              Cancel
            </Button>
          )}
        </div>
      )}
    </Card>
  );
}

export function IngredientPage() {
  const { id } = useParams<{ id: string }>();
  const queryClient = useQueryClient();
  const numericId = id == null ? Number.NaN : Number(id);
  const validId = !Number.isNaN(numericId) && numericId > 0;

  const { data, isLoading, isError } = useIngredientsRetrieve(
    validId ? numericId : 0,
    { query: { enabled: validId } }
  );
  const ingredient = data?.data;

  const { data: recipesData } = useRecipesList(undefined, { query: { enabled: validId } });
  const [allRecipes, setAllRecipes] = useState<NonNullable<typeof recipesData>['data']['results']>([]);

  useEffect(() => {
    if (recipesData) {
      fetchAllPages<NonNullable<typeof recipesData>['data']['results'][number]>(recipesData)
        .then(r => setAllRecipes(r));
    }
  }, [recipesData]);

  const usedInRecipes = useMemo(
    () => allRecipes.filter(r => r.ingredients_list.some(ri => ri.ingredient.id === numericId)),
    [allRecipes, numericId]
  );

  function invalidateIngredient() {
    queryClient.invalidateQueries({ queryKey: getIngredientsRetrieveQueryKey(numericId) });
  }

  if (!validId) {
    return (
      <div className="space-y-4">
        <Breadcrumbs items={[{ label: 'Ingredients', href: '/ingredients' }]} />
        <div className="text-center py-12">
          <p className="text-palette-text">Invalid ingredient</p>
        </div>
      </div>
    );
  }

  if (isLoading) {
    return <div className="text-center py-12 text-palette-textMuted">Loading…</div>;
  }

  if (isError || !ingredient) {
    return (
      <div className="space-y-4">
        <Breadcrumbs items={[{ label: 'Ingredients', href: '/ingredients' }]} />
        <div className="text-center py-12">
          <p className="text-palette-text">Ingredient not found</p>
        </div>
      </div>
    );
  }

  const stats = ingredient.nutrition_stats;
  const unit = stats?.base_unit ?? 'unit';
  const aggregatedStats = stats ? multiplyNutritionStats(stats, 1) : null;

  return (
    <div className="space-y-6">
      <Breadcrumbs
        items={[
          { label: 'Ingredients', href: '/ingredients' },
          { label: ingredient.name },
        ]}
      />
      <h2 className="text-2xl font-semibold text-palette-text">{ingredient.name}</h2>

      <div className="grid grid-cols-1 gap-4 md:grid-cols-2 md:gap-6">
        <div className="h-full">
          <OnHandForm
            ingredient={ingredient}
            ingredientId={numericId}
            existing={ingredient.on_hand}
            onSaved={invalidateIngredient}
          />
        </div>

        <div className="h-full">
          {aggregatedStats ? (
            <Card className="h-full p-4">
              <NutritionLabel nutritionStats={aggregatedStats} per_unit={unit} />
            </Card>
          ) : (
            <Card className="h-full p-4">
              <h3 className="font-semibold text-lg mb-3">Nutrition Facts</h3>
              <p className="text-sm text-palette-textMuted">No nutrition data available.</p>
            </Card>
          )}
        </div>

        <Card className="h-full p-4">
          <h3 className="font-semibold text-lg mb-3">Used in recipes</h3>
          {usedInRecipes.length === 0 ? (
            <p className="text-sm text-palette-textMuted">Not used in any recipes.</p>
          ) : (
            <div className="space-y-3">
              {usedInRecipes.map(recipe => (
                <RecipeCard key={recipe.id} recipe={recipe} compact />
              ))}
            </div>
          )}
        </Card>

        <div className="h-full">
          <CostForm
            ingredient={ingredient}
            ingredientId={numericId}
            onSaved={invalidateIngredient}
          />
        </div>
      </div>
    </div>
  );
}
