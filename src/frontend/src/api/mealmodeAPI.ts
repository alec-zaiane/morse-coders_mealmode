/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Mealmode API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * * `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count
 */
export type BaseUnitEnum = typeof BaseUnitEnum[keyof typeof BaseUnitEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BaseUnitEnum = {
  kg: 'kg',
  L: 'L',
  pc: 'pc',
} as const;

/**
 * * `monday` - Monday
* `tuesday` - Tuesday
* `wednesday` - Wednesday
* `thursday` - Thursday
* `friday` - Friday
* `saturday` - Saturday
* `sunday` - Sunday
 */
export type DayEnum = typeof DayEnum[keyof typeof DayEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DayEnum = {
  monday: 'monday',
  tuesday: 'tuesday',
  wednesday: 'wednesday',
  thursday: 'thursday',
  friday: 'friday',
  saturday: 'saturday',
  sunday: 'sunday',
} as const;

/**
 * @nullable
 */
export type IngredientOnHand = OnHandIngredient | null;

/**
 * @nullable
 */
export type IngredientScraper = Scraper | null;

export interface Ingredient {
  readonly id: number;
  /** @maxLength 256 */
  name: string;
  readonly nutrition_stats: NutritionStats;
  /**
   * Estimated per base unit (e.g., $/kg), used as a fallback if no on-hand cost data is available
   * @nullable
   */
  estimated_cost?: number | null;
  /** @nullable */
  readonly on_hand: IngredientOnHand;
  /** @nullable */
  readonly scraper: IngredientScraper;
}

export interface MealPlanEntry {
  readonly id: number;
  recipe: number;
  /** Day of the week

* `monday` - Monday
* `tuesday` - Tuesday
* `wednesday` - Wednesday
* `thursday` - Thursday
* `friday` - Friday
* `saturday` - Saturday
* `sunday` - Sunday */
  day: DayEnum;
  /** Meal slot (e.g. breakfast, lunch, dinner)

* `breakfast` - Breakfast
* `lunch` - Lunch
* `dinner` - Dinner
* `snack` - Snack */
  slot: SlotEnum;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  servings?: number;
}

export interface NutritionStats {
  readonly id: number;
  /** The base unit for the nutrition stats (e.g., per kg, per liter, etc.)

* `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count */
  base_unit?: BaseUnitEnum;
  /**
   * Calories (Kcal) per base unit
   * @nullable
   */
  kcal_per_unit?: number | null;
  /**
   * Saturated fat (g) per base unit
   * @nullable
   */
  fat_saturated_grams_per_unit?: number | null;
  /**
   * Trans fat (g) per base unit
   * @nullable
   */
  fat_trans_grams_per_unit?: number | null;
  /**
   * Fiber (g) per base unit
   * @nullable
   */
  carbohydrate_fiber_grams_per_unit?: number | null;
  /**
   * Sugars (g) per base unit
   * @nullable
   */
  carbohydrate_sugar_grams_per_unit?: number | null;
  /**
   * Protein (g) per base unit
   * @nullable
   */
  protein_grams_per_unit?: number | null;
  /**
   * Cholesterol (mg) per base unit
   * @nullable
   */
  cholesterol_milligrams_per_unit?: number | null;
  /**
   * Sodium (mg) per base unit
   * @nullable
   */
  sodium_milligrams_per_unit?: number | null;
  /**
   * Potassium (mg) per base unit
   * @nullable
   */
  potassium_milligrams_per_unit?: number | null;
  /**
   * Calcium (mg) per base unit
   * @nullable
   */
  calcium_milligrams_per_unit?: number | null;
  /**
   * Iron (mg) per base unit
   * @nullable
   */
  iron_milligrams_per_unit?: number | null;
  /**
   * Vitamin A (mg) per base unit
   * @nullable
   */
  vitamin_a_milligrams_per_unit?: number | null;
  /**
   * Vitamin C (mg) per base unit
   * @nullable
   */
  vitamin_c_milligrams_per_unit?: number | null;
  /**
   * Vitamin D (mg) per base unit
   * @nullable
   */
  vitamin_d_milligrams_per_unit?: number | null;
  /** @nullable */
  ingredient?: number | null;
}

export interface OnHandIngredient {
  readonly id: number;
  ingredient: number;
  /**
   * Quantity of the ingredient currently on hand
   * @nullable
   */
  quantity?: number | null;
  /**
   * Desired quantity of the ingredient to have on hand (e.g., for meal planning)
   * @nullable
   */
  desired_quantity?: number | null;
  /**
   * Optional warning threshold quantity (e.g., if quantity on hand falls below this, issue a warning)
   * @nullable
   */
  warning_quantity?: number | null;
  /** Optional notes about the ingredient on hand */
  notes?: string;
}

export interface PaginatedIngredientList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Ingredient[];
}

export interface PaginatedMealPlanEntryList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: MealPlanEntry[];
}

export interface PaginatedOnHandIngredientList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: OnHandIngredient[];
}

export interface PaginatedRecipeList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Recipe[];
}

export interface PaginatedScraperList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Scraper[];
}

export interface PaginatedSourceList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Source[];
}

export interface PaginatedTagList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Tag[];
}

/**
 * @nullable
 */
export type PatchedIngredientOnHand = OnHandIngredient | null;

/**
 * @nullable
 */
export type PatchedIngredientScraper = Scraper | null;

export interface PatchedIngredient {
  readonly id?: number;
  /** @maxLength 256 */
  name?: string;
  readonly nutrition_stats?: NutritionStats;
  /**
   * Estimated per base unit (e.g., $/kg), used as a fallback if no on-hand cost data is available
   * @nullable
   */
  estimated_cost?: number | null;
  /** @nullable */
  readonly on_hand?: PatchedIngredientOnHand;
  /** @nullable */
  readonly scraper?: PatchedIngredientScraper;
}

export interface PatchedOnHandIngredient {
  readonly id?: number;
  ingredient?: number;
  /**
   * Quantity of the ingredient currently on hand
   * @nullable
   */
  quantity?: number | null;
  /**
   * Desired quantity of the ingredient to have on hand (e.g., for meal planning)
   * @nullable
   */
  desired_quantity?: number | null;
  /**
   * Optional warning threshold quantity (e.g., if quantity on hand falls below this, issue a warning)
   * @nullable
   */
  warning_quantity?: number | null;
  /** Optional notes about the ingredient on hand */
  notes?: string;
}

export interface PatchedRecipe {
  readonly id?: number;
  readonly ingredients_list?: readonly RecipeIngredient[];
  recipe_ingredients?: RecipeIngredientWrite[];
  recipe_steps?: RecipeStepWrite[];
  readonly tags?: readonly Tag[];
  readonly steps?: readonly RecipeStep[];
  tag_ids?: number[];
  /** @maxLength 100 */
  name?: string;
  /**
   * Number of servings this recipe makes
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  servings?: number;
  /**
   * Preparation time in minutes
   * @nullable
   */
  prep_time_minutes?: number | null;
  /**
   * Cooking time in minutes
   * @nullable
   */
  cook_time_minutes?: number | null;
  /** Optional notes about the recipe */
  notes?: string;
  readonly ingredients?: readonly number[];
}

export interface PatchedScraper {
  readonly id?: number;
  readonly cached_source?: Source;
  readonly sources?: readonly Source[];
  /** @nullable */
  cached_price?: number | null;
  readonly updated_at?: string;
  /** @nullable */
  ingredient?: number | null;
}

export interface PatchedSource {
  readonly id?: number;
  /** @maxLength 100 */
  url?: string;
  readonly updated_at?: string;
  /** @nullable */
  cached_price?: number | null;
  /**
   * @maxLength 200
   * @nullable
   */
  cached_error?: string | null;
  /** The base unit for the Source stats (e.g., per kg, per liter, etc.)

* `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count */
  quantity_unit?: QuantityUnitEnum;
  quantity?: number;
  scraper?: number;
}

export interface PatchedTag {
  readonly id?: number;
  /** @maxLength 50 */
  name?: string;
}

/**
 * * `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count
 */
export type QuantityUnitEnum = typeof QuantityUnitEnum[keyof typeof QuantityUnitEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const QuantityUnitEnum = {
  kg: 'kg',
  L: 'L',
  pc: 'pc',
} as const;

export interface Recipe {
  readonly id: number;
  readonly ingredients_list: readonly RecipeIngredient[];
  recipe_ingredients?: RecipeIngredientWrite[];
  recipe_steps?: RecipeStepWrite[];
  readonly tags: readonly Tag[];
  readonly steps: readonly RecipeStep[];
  tag_ids?: number[];
  /** @maxLength 100 */
  name: string;
  /**
   * Number of servings this recipe makes
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  servings?: number;
  /**
   * Preparation time in minutes
   * @nullable
   */
  prep_time_minutes?: number | null;
  /**
   * Cooking time in minutes
   * @nullable
   */
  cook_time_minutes?: number | null;
  /** Optional notes about the recipe */
  notes?: string;
  readonly ingredients: readonly number[];
}

export interface RecipeIngredient {
  readonly id: number;
  readonly ingredient: Ingredient;
  /** Quantity in base units (e.g., grams, liters, pieces), defined by the ingredient's nutrition stats) */
  quantity: number;
}

/**
 * For create/update: list of {ingredient: id, quantity}.
 */
export interface RecipeIngredientWrite {
  ingredient: number;
  /** @minimum 0 */
  quantity: number;
}

export interface RecipeStep {
  readonly id: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  step_number: number;
  description: string;
  recipe: number;
}

/**
 * For create/update: list of {step_number, description}.
 */
export interface RecipeStepWrite {
  /** @minimum 1 */
  step_number: number;
  description: string;
}

export interface Scraper {
  readonly id: number;
  readonly cached_source: Source;
  readonly sources: readonly Source[];
  /** @nullable */
  cached_price?: number | null;
  readonly updated_at: string;
  /** @nullable */
  ingredient?: number | null;
}

/**
 * * `breakfast` - Breakfast
* `lunch` - Lunch
* `dinner` - Dinner
* `snack` - Snack
 */
export type SlotEnum = typeof SlotEnum[keyof typeof SlotEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SlotEnum = {
  breakfast: 'breakfast',
  lunch: 'lunch',
  dinner: 'dinner',
  snack: 'snack',
} as const;

export interface Source {
  readonly id: number;
  /** @maxLength 100 */
  url: string;
  readonly updated_at: string;
  /** @nullable */
  cached_price?: number | null;
  /**
   * @maxLength 200
   * @nullable
   */
  cached_error?: string | null;
  /** The base unit for the Source stats (e.g., per kg, per liter, etc.)

* `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count */
  quantity_unit?: QuantityUnitEnum;
  quantity: number;
  scraper: number;
}

export interface Tag {
  readonly id: number;
  /** @maxLength 50 */
  name: string;
}

export type IngredientStoreListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export type IngredientsListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
on_hand__isnull?: boolean;
/**
 * A search term.
 */
search?: string;
};

export type MealPlanEntriesListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export type RecipesListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export type ScrapersListParams = {
ingredient?: number;
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export type SourcesListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
scraper?: number;
};

export type TagsListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
/**
 * A search term.
 */
search?: string;
};

export const ingredientStoreList = (
    params?: IngredientStoreListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedOnHandIngredientList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredient-store/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getIngredientStoreListQueryKey = (params?: IngredientStoreListParams,) => {
    return [
    `http://localhost:8000/api/ingredient-store/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getIngredientStoreListQueryOptions = <TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientStoreListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientStoreList>>> = ({ signal }) => ingredientStoreList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientStoreListQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreList>>>
export type IngredientStoreListQueryError = AxiosError<unknown>


export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params: undefined |  IngredientStoreListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreList>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreList>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientStoreListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientStoreCreate = (
    onHandIngredient: NonReadonly<OnHandIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/ingredient-store/`,
      onHandIngredient,options
    );
  }



export const getIngredientStoreCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreCreate>>, TError,{data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreCreate>>, TError,{data: NonReadonly<OnHandIngredient>}, TContext> => {

const mutationKey = ['ingredientStoreCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStoreCreate>>, {data: NonReadonly<OnHandIngredient>}> = (props) => {
          const {data} = props ?? {};

          return  ingredientStoreCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStoreCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreCreate>>>
    export type IngredientStoreCreateMutationBody = NonReadonly<OnHandIngredient>
    export type IngredientStoreCreateMutationError = AxiosError<unknown>

    export const useIngredientStoreCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreCreate>>, TError,{data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStoreCreate>>,
        TError,
        {data: NonReadonly<OnHandIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientStoreCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientStoreRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredient-store/${id}/`,options
    );
  }




export const getIngredientStoreRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/ingredient-store/${id}/`
    ] as const;
    }

    
export const getIngredientStoreRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientStoreRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientStoreRetrieve>>> = ({ signal }) => ingredientStoreRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientStoreRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreRetrieve>>>
export type IngredientStoreRetrieveQueryError = AxiosError<unknown>


export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientStoreRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientStoreUpdate = (
    id: number,
    onHandIngredient: NonReadonly<OnHandIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/ingredient-store/${id}/`,
      onHandIngredient,options
    );
  }



export const getIngredientStoreUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreUpdate>>, TError,{id: number;data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreUpdate>>, TError,{id: number;data: NonReadonly<OnHandIngredient>}, TContext> => {

const mutationKey = ['ingredientStoreUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStoreUpdate>>, {id: number;data: NonReadonly<OnHandIngredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientStoreUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStoreUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreUpdate>>>
    export type IngredientStoreUpdateMutationBody = NonReadonly<OnHandIngredient>
    export type IngredientStoreUpdateMutationError = AxiosError<unknown>

    export const useIngredientStoreUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreUpdate>>, TError,{id: number;data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStoreUpdate>>,
        TError,
        {id: number;data: NonReadonly<OnHandIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientStoreUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientStorePartialUpdate = (
    id: number,
    patchedOnHandIngredient: NonReadonly<PatchedOnHandIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/ingredient-store/${id}/`,
      patchedOnHandIngredient,options
    );
  }



export const getIngredientStorePartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedOnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedOnHandIngredient>}, TContext> => {

const mutationKey = ['ingredientStorePartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, {id: number;data: NonReadonly<PatchedOnHandIngredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientStorePartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStorePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>>
    export type IngredientStorePartialUpdateMutationBody = NonReadonly<PatchedOnHandIngredient>
    export type IngredientStorePartialUpdateMutationError = AxiosError<unknown>

    export const useIngredientStorePartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedOnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStorePartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedOnHandIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientStorePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientStoreDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/ingredient-store/${id}/`,options
    );
  }



export const getIngredientStoreDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['ingredientStoreDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStoreDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  ingredientStoreDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStoreDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreDestroy>>>
    
    export type IngredientStoreDestroyMutationError = AxiosError<unknown>

    export const useIngredientStoreDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStoreDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getIngredientStoreDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsList = (
    params?: IngredientsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedIngredientList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredients/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getIngredientsListQueryKey = (params?: IngredientsListParams,) => {
    return [
    `http://localhost:8000/api/ingredients/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getIngredientsListQueryOptions = <TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientsList>>> = ({ signal }) => ingredientsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientsListQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientsList>>>
export type IngredientsListQueryError = AxiosError<unknown>


export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params: undefined |  IngredientsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsList>>,
          TError,
          Awaited<ReturnType<typeof ingredientsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsList>>,
          TError,
          Awaited<ReturnType<typeof ingredientsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientsCreate = (
    ingredient: NonReadonly<Ingredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/ingredients/`,
      ingredient,options
    );
  }



export const getIngredientsCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext> => {

const mutationKey = ['ingredientsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsCreate>>, {data: NonReadonly<Ingredient>}> = (props) => {
          const {data} = props ?? {};

          return  ingredientsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsCreate>>>
    export type IngredientsCreateMutationBody = NonReadonly<Ingredient>
    export type IngredientsCreateMutationError = AxiosError<unknown>

    export const useIngredientsCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsCreate>>,
        TError,
        {data: NonReadonly<Ingredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredients/${id}/`,options
    );
  }




export const getIngredientsRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/ingredients/${id}/`
    ] as const;
    }

    
export const getIngredientsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientsRetrieve>>> = ({ signal }) => ingredientsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientsRetrieve>>>
export type IngredientsRetrieveQueryError = AxiosError<unknown>


export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientsUpdate = (
    id: number,
    ingredient: NonReadonly<Ingredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/ingredients/${id}/`,
      ingredient,options
    );
  }



export const getIngredientsUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext> => {

const mutationKey = ['ingredientsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsUpdate>>, {id: number;data: NonReadonly<Ingredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsUpdate>>>
    export type IngredientsUpdateMutationBody = NonReadonly<Ingredient>
    export type IngredientsUpdateMutationError = AxiosError<unknown>

    export const useIngredientsUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Ingredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsPartialUpdate = (
    id: number,
    patchedIngredient: NonReadonly<PatchedIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/ingredients/${id}/`,
      patchedIngredient,options
    );
  }



export const getIngredientsPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext> => {

const mutationKey = ['ingredientsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, {id: number;data: NonReadonly<PatchedIngredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsPartialUpdate>>>
    export type IngredientsPartialUpdateMutationBody = NonReadonly<PatchedIngredient>
    export type IngredientsPartialUpdateMutationError = AxiosError<unknown>

    export const useIngredientsPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/ingredients/${id}/`,options
    );
  }



export const getIngredientsDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['ingredientsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  ingredientsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsDestroy>>>
    
    export type IngredientsDestroyMutationError = AxiosError<unknown>

    export const useIngredientsDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getIngredientsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const mealPlanEntriesList = (
    params?: MealPlanEntriesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedMealPlanEntryList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/meal-plan-entries/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getMealPlanEntriesListQueryKey = (params?: MealPlanEntriesListParams,) => {
    return [
    `http://localhost:8000/api/meal-plan-entries/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getMealPlanEntriesListQueryOptions = <TData = Awaited<ReturnType<typeof mealPlanEntriesList>>, TError = AxiosError<unknown>>(params?: MealPlanEntriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMealPlanEntriesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mealPlanEntriesList>>> = ({ signal }) => mealPlanEntriesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MealPlanEntriesListQueryResult = NonNullable<Awaited<ReturnType<typeof mealPlanEntriesList>>>
export type MealPlanEntriesListQueryError = AxiosError<unknown>


export function useMealPlanEntriesList<TData = Awaited<ReturnType<typeof mealPlanEntriesList>>, TError = AxiosError<unknown>>(
 params: undefined |  MealPlanEntriesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mealPlanEntriesList>>,
          TError,
          Awaited<ReturnType<typeof mealPlanEntriesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMealPlanEntriesList<TData = Awaited<ReturnType<typeof mealPlanEntriesList>>, TError = AxiosError<unknown>>(
 params?: MealPlanEntriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mealPlanEntriesList>>,
          TError,
          Awaited<ReturnType<typeof mealPlanEntriesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMealPlanEntriesList<TData = Awaited<ReturnType<typeof mealPlanEntriesList>>, TError = AxiosError<unknown>>(
 params?: MealPlanEntriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMealPlanEntriesList<TData = Awaited<ReturnType<typeof mealPlanEntriesList>>, TError = AxiosError<unknown>>(
 params?: MealPlanEntriesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMealPlanEntriesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const mealPlanEntriesCreate = (
    mealPlanEntry: NonReadonly<MealPlanEntry>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MealPlanEntry>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/meal-plan-entries/`,
      mealPlanEntry,options
    );
  }



export const getMealPlanEntriesCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mealPlanEntriesCreate>>, TError,{data: NonReadonly<MealPlanEntry>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof mealPlanEntriesCreate>>, TError,{data: NonReadonly<MealPlanEntry>}, TContext> => {

const mutationKey = ['mealPlanEntriesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mealPlanEntriesCreate>>, {data: NonReadonly<MealPlanEntry>}> = (props) => {
          const {data} = props ?? {};

          return  mealPlanEntriesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MealPlanEntriesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof mealPlanEntriesCreate>>>
    export type MealPlanEntriesCreateMutationBody = NonReadonly<MealPlanEntry>
    export type MealPlanEntriesCreateMutationError = AxiosError<unknown>

    export const useMealPlanEntriesCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mealPlanEntriesCreate>>, TError,{data: NonReadonly<MealPlanEntry>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mealPlanEntriesCreate>>,
        TError,
        {data: NonReadonly<MealPlanEntry>},
        TContext
      > => {

      const mutationOptions = getMealPlanEntriesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const mealPlanEntriesRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MealPlanEntry>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/meal-plan-entries/${id}/`,options
    );
  }




export const getMealPlanEntriesRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/meal-plan-entries/${id}/`
    ] as const;
    }

    
export const getMealPlanEntriesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMealPlanEntriesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>> = ({ signal }) => mealPlanEntriesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type MealPlanEntriesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>>
export type MealPlanEntriesRetrieveQueryError = AxiosError<unknown>


export function useMealPlanEntriesRetrieve<TData = Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMealPlanEntriesRetrieve<TData = Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useMealPlanEntriesRetrieve<TData = Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useMealPlanEntriesRetrieve<TData = Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof mealPlanEntriesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMealPlanEntriesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const mealPlanEntriesDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/meal-plan-entries/${id}/`,options
    );
  }



export const getMealPlanEntriesDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mealPlanEntriesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof mealPlanEntriesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['mealPlanEntriesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof mealPlanEntriesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  mealPlanEntriesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MealPlanEntriesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof mealPlanEntriesDestroy>>>
    
    export type MealPlanEntriesDestroyMutationError = AxiosError<unknown>

    export const useMealPlanEntriesDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof mealPlanEntriesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof mealPlanEntriesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getMealPlanEntriesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesList = (
    params?: RecipesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedRecipeList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/recipes/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getRecipesListQueryKey = (params?: RecipesListParams,) => {
    return [
    `http://localhost:8000/api/recipes/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getRecipesListQueryOptions = <TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRecipesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof recipesList>>> = ({ signal }) => recipesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecipesListQueryResult = NonNullable<Awaited<ReturnType<typeof recipesList>>>
export type RecipesListQueryError = AxiosError<unknown>


export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params: undefined |  RecipesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesList>>,
          TError,
          Awaited<ReturnType<typeof recipesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesList>>,
          TError,
          Awaited<ReturnType<typeof recipesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRecipesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const recipesCreate = (
    recipe: NonReadonly<Recipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/recipes/`,
      recipe,options
    );
  }



export const getRecipesCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext> => {

const mutationKey = ['recipesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesCreate>>, {data: NonReadonly<Recipe>}> = (props) => {
          const {data} = props ?? {};

          return  recipesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesCreate>>>
    export type RecipesCreateMutationBody = NonReadonly<Recipe>
    export type RecipesCreateMutationError = AxiosError<unknown>

    export const useRecipesCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesCreate>>,
        TError,
        {data: NonReadonly<Recipe>},
        TContext
      > => {

      const mutationOptions = getRecipesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/recipes/${id}/`,options
    );
  }




export const getRecipesRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/recipes/${id}/`
    ] as const;
    }

    
export const getRecipesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRecipesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof recipesRetrieve>>> = ({ signal }) => recipesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecipesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof recipesRetrieve>>>
export type RecipesRetrieveQueryError = AxiosError<unknown>


export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof recipesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof recipesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRecipesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const recipesUpdate = (
    id: number,
    recipe: NonReadonly<Recipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/recipes/${id}/`,
      recipe,options
    );
  }



export const getRecipesUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext> => {

const mutationKey = ['recipesUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesUpdate>>, {id: number;data: NonReadonly<Recipe>}> = (props) => {
          const {id,data} = props ?? {};

          return  recipesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesUpdate>>>
    export type RecipesUpdateMutationBody = NonReadonly<Recipe>
    export type RecipesUpdateMutationError = AxiosError<unknown>

    export const useRecipesUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesUpdate>>,
        TError,
        {id: number;data: NonReadonly<Recipe>},
        TContext
      > => {

      const mutationOptions = getRecipesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesPartialUpdate = (
    id: number,
    patchedRecipe: NonReadonly<PatchedRecipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/recipes/${id}/`,
      patchedRecipe,options
    );
  }



export const getRecipesPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext> => {

const mutationKey = ['recipesPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesPartialUpdate>>, {id: number;data: NonReadonly<PatchedRecipe>}> = (props) => {
          const {id,data} = props ?? {};

          return  recipesPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesPartialUpdate>>>
    export type RecipesPartialUpdateMutationBody = NonReadonly<PatchedRecipe>
    export type RecipesPartialUpdateMutationError = AxiosError<unknown>

    export const useRecipesPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedRecipe>},
        TContext
      > => {

      const mutationOptions = getRecipesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/recipes/${id}/`,options
    );
  }



export const getRecipesDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['recipesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  recipesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof recipesDestroy>>>
    
    export type RecipesDestroyMutationError = AxiosError<unknown>

    export const useRecipesDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getRecipesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const scrapersList = (
    params?: ScrapersListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedScraperList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/scrapers/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getScrapersListQueryKey = (params?: ScrapersListParams,) => {
    return [
    `http://localhost:8000/api/scrapers/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getScrapersListQueryOptions = <TData = Awaited<ReturnType<typeof scrapersList>>, TError = AxiosError<unknown>>(params?: ScrapersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getScrapersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scrapersList>>> = ({ signal }) => scrapersList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scrapersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ScrapersListQueryResult = NonNullable<Awaited<ReturnType<typeof scrapersList>>>
export type ScrapersListQueryError = AxiosError<unknown>


export function useScrapersList<TData = Awaited<ReturnType<typeof scrapersList>>, TError = AxiosError<unknown>>(
 params: undefined |  ScrapersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrapersList>>,
          TError,
          Awaited<ReturnType<typeof scrapersList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScrapersList<TData = Awaited<ReturnType<typeof scrapersList>>, TError = AxiosError<unknown>>(
 params?: ScrapersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrapersList>>,
          TError,
          Awaited<ReturnType<typeof scrapersList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScrapersList<TData = Awaited<ReturnType<typeof scrapersList>>, TError = AxiosError<unknown>>(
 params?: ScrapersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useScrapersList<TData = Awaited<ReturnType<typeof scrapersList>>, TError = AxiosError<unknown>>(
 params?: ScrapersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getScrapersListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const scrapersCreate = (
    scraper: NonReadonly<Scraper>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scraper>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/scrapers/`,
      scraper,options
    );
  }



export const getScrapersCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersCreate>>, TError,{data: NonReadonly<Scraper>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scrapersCreate>>, TError,{data: NonReadonly<Scraper>}, TContext> => {

const mutationKey = ['scrapersCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrapersCreate>>, {data: NonReadonly<Scraper>}> = (props) => {
          const {data} = props ?? {};

          return  scrapersCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrapersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof scrapersCreate>>>
    export type ScrapersCreateMutationBody = NonReadonly<Scraper>
    export type ScrapersCreateMutationError = AxiosError<unknown>

    export const useScrapersCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersCreate>>, TError,{data: NonReadonly<Scraper>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof scrapersCreate>>,
        TError,
        {data: NonReadonly<Scraper>},
        TContext
      > => {

      const mutationOptions = getScrapersCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const scrapersRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scraper>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/scrapers/${id}/`,options
    );
  }




export const getScrapersRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/scrapers/${id}/`
    ] as const;
    }

    
export const getScrapersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof scrapersRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getScrapersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scrapersRetrieve>>> = ({ signal }) => scrapersRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scrapersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ScrapersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof scrapersRetrieve>>>
export type ScrapersRetrieveQueryError = AxiosError<unknown>


export function useScrapersRetrieve<TData = Awaited<ReturnType<typeof scrapersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrapersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof scrapersRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScrapersRetrieve<TData = Awaited<ReturnType<typeof scrapersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof scrapersRetrieve>>,
          TError,
          Awaited<ReturnType<typeof scrapersRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScrapersRetrieve<TData = Awaited<ReturnType<typeof scrapersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useScrapersRetrieve<TData = Awaited<ReturnType<typeof scrapersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scrapersRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getScrapersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const scrapersUpdate = (
    id: number,
    scraper: NonReadonly<Scraper>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scraper>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/scrapers/${id}/`,
      scraper,options
    );
  }



export const getScrapersUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersUpdate>>, TError,{id: number;data: NonReadonly<Scraper>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scrapersUpdate>>, TError,{id: number;data: NonReadonly<Scraper>}, TContext> => {

const mutationKey = ['scrapersUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrapersUpdate>>, {id: number;data: NonReadonly<Scraper>}> = (props) => {
          const {id,data} = props ?? {};

          return  scrapersUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrapersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof scrapersUpdate>>>
    export type ScrapersUpdateMutationBody = NonReadonly<Scraper>
    export type ScrapersUpdateMutationError = AxiosError<unknown>

    export const useScrapersUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersUpdate>>, TError,{id: number;data: NonReadonly<Scraper>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof scrapersUpdate>>,
        TError,
        {id: number;data: NonReadonly<Scraper>},
        TContext
      > => {

      const mutationOptions = getScrapersUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const scrapersPartialUpdate = (
    id: number,
    patchedScraper: NonReadonly<PatchedScraper>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scraper>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/scrapers/${id}/`,
      patchedScraper,options
    );
  }



export const getScrapersPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedScraper>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scrapersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedScraper>}, TContext> => {

const mutationKey = ['scrapersPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrapersPartialUpdate>>, {id: number;data: NonReadonly<PatchedScraper>}> = (props) => {
          const {id,data} = props ?? {};

          return  scrapersPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrapersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof scrapersPartialUpdate>>>
    export type ScrapersPartialUpdateMutationBody = NonReadonly<PatchedScraper>
    export type ScrapersPartialUpdateMutationError = AxiosError<unknown>

    export const useScrapersPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedScraper>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof scrapersPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedScraper>},
        TContext
      > => {

      const mutationOptions = getScrapersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const scrapersDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/scrapers/${id}/`,options
    );
  }



export const getScrapersDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scrapersDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['scrapersDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrapersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  scrapersDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrapersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof scrapersDestroy>>>
    
    export type ScrapersDestroyMutationError = AxiosError<unknown>

    export const useScrapersDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof scrapersDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getScrapersDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Scrape all sources, update cached_price/cached_source, return updated scraper.
 */
export const scrapersRefreshCreate = (
    id: number,
    scraper: NonReadonly<Scraper>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Scraper>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/scrapers/${id}/refresh/`,
      scraper,options
    );
  }



export const getScrapersRefreshCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersRefreshCreate>>, TError,{id: number;data: NonReadonly<Scraper>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof scrapersRefreshCreate>>, TError,{id: number;data: NonReadonly<Scraper>}, TContext> => {

const mutationKey = ['scrapersRefreshCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof scrapersRefreshCreate>>, {id: number;data: NonReadonly<Scraper>}> = (props) => {
          const {id,data} = props ?? {};

          return  scrapersRefreshCreate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ScrapersRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof scrapersRefreshCreate>>>
    export type ScrapersRefreshCreateMutationBody = NonReadonly<Scraper>
    export type ScrapersRefreshCreateMutationError = AxiosError<unknown>

    export const useScrapersRefreshCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof scrapersRefreshCreate>>, TError,{id: number;data: NonReadonly<Scraper>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof scrapersRefreshCreate>>,
        TError,
        {id: number;data: NonReadonly<Scraper>},
        TContext
      > => {

      const mutationOptions = getScrapersRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const sourcesList = (
    params?: SourcesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedSourceList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/sources/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getSourcesListQueryKey = (params?: SourcesListParams,) => {
    return [
    `http://localhost:8000/api/sources/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getSourcesListQueryOptions = <TData = Awaited<ReturnType<typeof sourcesList>>, TError = AxiosError<unknown>>(params?: SourcesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSourcesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sourcesList>>> = ({ signal }) => sourcesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sourcesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SourcesListQueryResult = NonNullable<Awaited<ReturnType<typeof sourcesList>>>
export type SourcesListQueryError = AxiosError<unknown>


export function useSourcesList<TData = Awaited<ReturnType<typeof sourcesList>>, TError = AxiosError<unknown>>(
 params: undefined |  SourcesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sourcesList>>,
          TError,
          Awaited<ReturnType<typeof sourcesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSourcesList<TData = Awaited<ReturnType<typeof sourcesList>>, TError = AxiosError<unknown>>(
 params?: SourcesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sourcesList>>,
          TError,
          Awaited<ReturnType<typeof sourcesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSourcesList<TData = Awaited<ReturnType<typeof sourcesList>>, TError = AxiosError<unknown>>(
 params?: SourcesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSourcesList<TData = Awaited<ReturnType<typeof sourcesList>>, TError = AxiosError<unknown>>(
 params?: SourcesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSourcesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const sourcesCreate = (
    source: NonReadonly<Source>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Source>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/sources/`,
      source,options
    );
  }



export const getSourcesCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesCreate>>, TError,{data: NonReadonly<Source>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sourcesCreate>>, TError,{data: NonReadonly<Source>}, TContext> => {

const mutationKey = ['sourcesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sourcesCreate>>, {data: NonReadonly<Source>}> = (props) => {
          const {data} = props ?? {};

          return  sourcesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SourcesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof sourcesCreate>>>
    export type SourcesCreateMutationBody = NonReadonly<Source>
    export type SourcesCreateMutationError = AxiosError<unknown>

    export const useSourcesCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesCreate>>, TError,{data: NonReadonly<Source>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sourcesCreate>>,
        TError,
        {data: NonReadonly<Source>},
        TContext
      > => {

      const mutationOptions = getSourcesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const sourcesRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Source>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/sources/${id}/`,options
    );
  }




export const getSourcesRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/sources/${id}/`
    ] as const;
    }

    
export const getSourcesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof sourcesRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSourcesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sourcesRetrieve>>> = ({ signal }) => sourcesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sourcesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SourcesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof sourcesRetrieve>>>
export type SourcesRetrieveQueryError = AxiosError<unknown>


export function useSourcesRetrieve<TData = Awaited<ReturnType<typeof sourcesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sourcesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof sourcesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSourcesRetrieve<TData = Awaited<ReturnType<typeof sourcesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sourcesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof sourcesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSourcesRetrieve<TData = Awaited<ReturnType<typeof sourcesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useSourcesRetrieve<TData = Awaited<ReturnType<typeof sourcesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof sourcesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSourcesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const sourcesUpdate = (
    id: number,
    source: NonReadonly<Source>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Source>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/sources/${id}/`,
      source,options
    );
  }



export const getSourcesUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesUpdate>>, TError,{id: number;data: NonReadonly<Source>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sourcesUpdate>>, TError,{id: number;data: NonReadonly<Source>}, TContext> => {

const mutationKey = ['sourcesUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sourcesUpdate>>, {id: number;data: NonReadonly<Source>}> = (props) => {
          const {id,data} = props ?? {};

          return  sourcesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SourcesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof sourcesUpdate>>>
    export type SourcesUpdateMutationBody = NonReadonly<Source>
    export type SourcesUpdateMutationError = AxiosError<unknown>

    export const useSourcesUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesUpdate>>, TError,{id: number;data: NonReadonly<Source>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sourcesUpdate>>,
        TError,
        {id: number;data: NonReadonly<Source>},
        TContext
      > => {

      const mutationOptions = getSourcesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const sourcesPartialUpdate = (
    id: number,
    patchedSource: NonReadonly<PatchedSource>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Source>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/sources/${id}/`,
      patchedSource,options
    );
  }



export const getSourcesPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedSource>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sourcesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedSource>}, TContext> => {

const mutationKey = ['sourcesPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sourcesPartialUpdate>>, {id: number;data: NonReadonly<PatchedSource>}> = (props) => {
          const {id,data} = props ?? {};

          return  sourcesPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SourcesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof sourcesPartialUpdate>>>
    export type SourcesPartialUpdateMutationBody = NonReadonly<PatchedSource>
    export type SourcesPartialUpdateMutationError = AxiosError<unknown>

    export const useSourcesPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedSource>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sourcesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedSource>},
        TContext
      > => {

      const mutationOptions = getSourcesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const sourcesDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/sources/${id}/`,options
    );
  }



export const getSourcesDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sourcesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['sourcesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sourcesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  sourcesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SourcesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof sourcesDestroy>>>
    
    export type SourcesDestroyMutationError = AxiosError<unknown>

    export const useSourcesDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sourcesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sourcesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getSourcesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsList = (
    params?: TagsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedTagList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/tags/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getTagsListQueryKey = (params?: TagsListParams,) => {
    return [
    `http://localhost:8000/api/tags/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getTagsListQueryOptions = <TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsList>>> = ({ signal }) => tagsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TagsListQueryResult = NonNullable<Awaited<ReturnType<typeof tagsList>>>
export type TagsListQueryError = AxiosError<unknown>


export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params: undefined |  TagsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsList>>,
          TError,
          Awaited<ReturnType<typeof tagsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsList>>,
          TError,
          Awaited<ReturnType<typeof tagsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTagsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagsCreate = (
    tag: NonReadonly<Tag>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/tags/`,
      tag,options
    );
  }



export const getTagsCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext> => {

const mutationKey = ['tagsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsCreate>>, {data: NonReadonly<Tag>}> = (props) => {
          const {data} = props ?? {};

          return  tagsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsCreate>>>
    export type TagsCreateMutationBody = NonReadonly<Tag>
    export type TagsCreateMutationError = AxiosError<unknown>

    export const useTagsCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsCreate>>,
        TError,
        {data: NonReadonly<Tag>},
        TContext
      > => {

      const mutationOptions = getTagsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/tags/${id}/`,options
    );
  }




export const getTagsRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/tags/${id}/`
    ] as const;
    }

    
export const getTagsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsRetrieve>>> = ({ signal }) => tagsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TagsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof tagsRetrieve>>>
export type TagsRetrieveQueryError = AxiosError<unknown>


export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tagsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tagsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTagsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagsUpdate = (
    id: number,
    tag: NonReadonly<Tag>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/tags/${id}/`,
      tag,options
    );
  }



export const getTagsUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: number;data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: number;data: NonReadonly<Tag>}, TContext> => {

const mutationKey = ['tagsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsUpdate>>, {id: number;data: NonReadonly<Tag>}> = (props) => {
          const {id,data} = props ?? {};

          return  tagsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsUpdate>>>
    export type TagsUpdateMutationBody = NonReadonly<Tag>
    export type TagsUpdateMutationError = AxiosError<unknown>

    export const useTagsUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: number;data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Tag>},
        TContext
      > => {

      const mutationOptions = getTagsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsPartialUpdate = (
    id: number,
    patchedTag: NonReadonly<PatchedTag>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/tags/${id}/`,
      patchedTag,options
    );
  }



export const getTagsPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTag>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTag>}, TContext> => {

const mutationKey = ['tagsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsPartialUpdate>>, {id: number;data: NonReadonly<PatchedTag>}> = (props) => {
          const {id,data} = props ?? {};

          return  tagsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsPartialUpdate>>>
    export type TagsPartialUpdateMutationBody = NonReadonly<PatchedTag>
    export type TagsPartialUpdateMutationError = AxiosError<unknown>

    export const useTagsPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTag>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedTag>},
        TContext
      > => {

      const mutationOptions = getTagsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/tags/${id}/`,options
    );
  }



export const getTagsDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['tagsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  tagsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof tagsDestroy>>>
    
    export type TagsDestroyMutationError = AxiosError<unknown>

    export const useTagsDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getTagsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
