/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Mealmode API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * * `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count
 */
export type BaseUnitEnum = typeof BaseUnitEnum[keyof typeof BaseUnitEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BaseUnitEnum = {
  kg: 'kg',
  L: 'L',
  pc: 'pc',
} as const;

/**
 * @nullable
 */
export type IngredientOnHand = OnHandIngredient | null;

export interface Ingredient {
  readonly id: number;
  /** @maxLength 100 */
  name: string;
  readonly nutrition_stats: NutritionStats;
  /**
   * Lowest known cost per base unit (e.g., $/kg
   * @nullable
   */
  lowest_cost?: number | null;
  /** @nullable */
  readonly on_hand: IngredientOnHand;
}

export interface NutritionStats {
  readonly id: number;
  /** The base unit for the nutrition stats (e.g., per kg, per liter, etc.)

* `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count */
  base_unit?: BaseUnitEnum;
  /**
   * Calories (Kcal) per base unit
   * @nullable
   */
  kcal_per_unit?: number | null;
  /**
   * Saturated fat (g) per base unit
   * @nullable
   */
  fat_saturated_grams_per_unit?: number | null;
  /**
   * Trans fat (g) per base unit
   * @nullable
   */
  fat_trans_grams_per_unit?: number | null;
  /**
   * Fiber (g) per base unit
   * @nullable
   */
  carbohydrate_fiber_grams_per_unit?: number | null;
  /**
   * Sugars (g) per base unit
   * @nullable
   */
  carbohydrate_sugar_grams_per_unit?: number | null;
  /**
   * Protein (g) per base unit
   * @nullable
   */
  protein_grams_per_unit?: number | null;
  /**
   * Cholesterol (mg) per base unit
   * @nullable
   */
  cholesterol_milligrams_per_unit?: number | null;
  /**
   * Sodium (mg) per base unit
   * @nullable
   */
  sodium_milligrams_per_unit?: number | null;
  /**
   * Potassium (mg) per base unit
   * @nullable
   */
  potassium_milligrams_per_unit?: number | null;
  /**
   * Calcium (mg) per base unit
   * @nullable
   */
  calcium_milligrams_per_unit?: number | null;
  /**
   * Iron (mg) per base unit
   * @nullable
   */
  iron_milligrams_per_unit?: number | null;
  /**
   * Vitamin A (mg) per base unit
   * @nullable
   */
  vitamin_a_milligrams_per_unit?: number | null;
  /**
   * Vitamin C (mg) per base unit
   * @nullable
   */
  vitamin_c_milligrams_per_unit?: number | null;
  /**
   * Vitamin D (mg) per base unit
   * @nullable
   */
  vitamin_d_milligrams_per_unit?: number | null;
  /** @nullable */
  ingredient?: number | null;
}

export interface OnHandIngredient {
  readonly id: number;
  ingredient: number;
  /**
   * Quantity of the ingredient currently on hand
   * @nullable
   */
  quantity?: number | null;
  /**
   * Desired quantity of the ingredient to have on hand (e.g., for meal planning)
   * @nullable
   */
  desired_quantity?: number | null;
  /**
   * Optional warning threshold quantity (e.g., if quantity on hand falls below this, issue a warning)
   * @nullable
   */
  warning_quantity?: number | null;
  /** Optional notes about the ingredient on hand */
  notes?: string;
}

export interface PaginatedIngredientList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Ingredient[];
}

export interface PaginatedOnHandIngredientList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: OnHandIngredient[];
}

export interface PaginatedRecipeList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Recipe[];
}

export interface PaginatedTagList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Tag[];
}

/**
 * @nullable
 */
export type PatchedIngredientOnHand = OnHandIngredient | null;

export interface PatchedIngredient {
  readonly id?: number;
  /** @maxLength 100 */
  name?: string;
  readonly nutrition_stats?: NutritionStats;
  /**
   * Lowest known cost per base unit (e.g., $/kg
   * @nullable
   */
  lowest_cost?: number | null;
  /** @nullable */
  readonly on_hand?: PatchedIngredientOnHand;
}

export interface PatchedOnHandIngredient {
  readonly id?: number;
  ingredient?: number;
  /**
   * Quantity of the ingredient currently on hand
   * @nullable
   */
  quantity?: number | null;
  /**
   * Desired quantity of the ingredient to have on hand (e.g., for meal planning)
   * @nullable
   */
  desired_quantity?: number | null;
  /**
   * Optional warning threshold quantity (e.g., if quantity on hand falls below this, issue a warning)
   * @nullable
   */
  warning_quantity?: number | null;
  /** Optional notes about the ingredient on hand */
  notes?: string;
}

export interface PatchedRecipe {
  readonly id?: number;
  readonly ingredients_list?: readonly RecipeIngredient[];
  recipe_ingredients?: RecipeIngredientWrite[];
  recipe_steps?: RecipeStepWrite[];
  readonly tags?: readonly Tag[];
  readonly steps?: readonly RecipeStep[];
  /** @maxLength 100 */
  name?: string;
  /**
   * Number of servings this recipe makes
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  servings?: number;
  /**
   * Preparation time in minutes
   * @nullable
   */
  prep_time_minutes?: number | null;
  /**
   * Cooking time in minutes
   * @nullable
   */
  cook_time_minutes?: number | null;
  /** Optional notes about the recipe */
  notes?: string;
  readonly ingredients?: readonly number[];
}

export interface PatchedTag {
  readonly id?: number;
  /** @maxLength 50 */
  name?: string;
}

export interface Recipe {
  readonly id: number;
  readonly ingredients_list: readonly RecipeIngredient[];
  recipe_ingredients?: RecipeIngredientWrite[];
  recipe_steps?: RecipeStepWrite[];
  readonly tags: readonly Tag[];
  readonly steps: readonly RecipeStep[];
  /** @maxLength 100 */
  name: string;
  /**
   * Number of servings this recipe makes
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  servings?: number;
  /**
   * Preparation time in minutes
   * @nullable
   */
  prep_time_minutes?: number | null;
  /**
   * Cooking time in minutes
   * @nullable
   */
  cook_time_minutes?: number | null;
  /** Optional notes about the recipe */
  notes?: string;
  readonly ingredients: readonly number[];
}

export interface RecipeIngredient {
  readonly id: number;
  readonly ingredient: Ingredient;
  /** Quantity in base units (e.g., grams, liters, pieces), defined by the ingredient's nutrition stats) */
  quantity: number;
}

/**
 * For create/update: list of {ingredient: id, quantity}.
 */
export interface RecipeIngredientWrite {
  ingredient: number;
  /** @minimum 0 */
  quantity: number;
}

export interface RecipeStep {
  readonly id: number;
  /**
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  step_number: number;
  description: string;
  recipe: number;
}

/**
 * For create/update: list of {step_number, description}.
 */
export interface RecipeStepWrite {
  /** @minimum 1 */
  step_number: number;
  description: string;
}

export interface Tag {
  readonly id: number;
  /** @maxLength 50 */
  name: string;
}

export type IngredientStoreListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export type IngredientsListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
/**
 * A search term.
 */
search?: string;
};

export type RecipesListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export type TagsListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export const ingredientStoreList = (
    params?: IngredientStoreListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedOnHandIngredientList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredient-store/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getIngredientStoreListQueryKey = (params?: IngredientStoreListParams,) => {
    return [
    `http://localhost:8000/api/ingredient-store/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getIngredientStoreListQueryOptions = <TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientStoreListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientStoreList>>> = ({ signal }) => ingredientStoreList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientStoreListQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreList>>>
export type IngredientStoreListQueryError = AxiosError<unknown>


export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params: undefined |  IngredientStoreListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreList>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreList>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientStoreList<TData = Awaited<ReturnType<typeof ingredientStoreList>>, TError = AxiosError<unknown>>(
 params?: IngredientStoreListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientStoreListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientStoreCreate = (
    onHandIngredient: NonReadonly<OnHandIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/ingredient-store/`,
      onHandIngredient,options
    );
  }



export const getIngredientStoreCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreCreate>>, TError,{data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreCreate>>, TError,{data: NonReadonly<OnHandIngredient>}, TContext> => {

const mutationKey = ['ingredientStoreCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStoreCreate>>, {data: NonReadonly<OnHandIngredient>}> = (props) => {
          const {data} = props ?? {};

          return  ingredientStoreCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStoreCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreCreate>>>
    export type IngredientStoreCreateMutationBody = NonReadonly<OnHandIngredient>
    export type IngredientStoreCreateMutationError = AxiosError<unknown>

    export const useIngredientStoreCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreCreate>>, TError,{data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStoreCreate>>,
        TError,
        {data: NonReadonly<OnHandIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientStoreCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientStoreRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredient-store/${id}/`,options
    );
  }




export const getIngredientStoreRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/ingredient-store/${id}/`
    ] as const;
    }

    
export const getIngredientStoreRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientStoreRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientStoreRetrieve>>> = ({ signal }) => ingredientStoreRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientStoreRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreRetrieve>>>
export type IngredientStoreRetrieveQueryError = AxiosError<unknown>


export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientStoreRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientStoreRetrieve<TData = Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientStoreRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientStoreRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientStoreUpdate = (
    id: number,
    onHandIngredient: NonReadonly<OnHandIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/ingredient-store/${id}/`,
      onHandIngredient,options
    );
  }



export const getIngredientStoreUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreUpdate>>, TError,{id: number;data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreUpdate>>, TError,{id: number;data: NonReadonly<OnHandIngredient>}, TContext> => {

const mutationKey = ['ingredientStoreUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStoreUpdate>>, {id: number;data: NonReadonly<OnHandIngredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientStoreUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStoreUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreUpdate>>>
    export type IngredientStoreUpdateMutationBody = NonReadonly<OnHandIngredient>
    export type IngredientStoreUpdateMutationError = AxiosError<unknown>

    export const useIngredientStoreUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreUpdate>>, TError,{id: number;data: NonReadonly<OnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStoreUpdate>>,
        TError,
        {id: number;data: NonReadonly<OnHandIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientStoreUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientStorePartialUpdate = (
    id: number,
    patchedOnHandIngredient: NonReadonly<PatchedOnHandIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<OnHandIngredient>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/ingredient-store/${id}/`,
      patchedOnHandIngredient,options
    );
  }



export const getIngredientStorePartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedOnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedOnHandIngredient>}, TContext> => {

const mutationKey = ['ingredientStorePartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, {id: number;data: NonReadonly<PatchedOnHandIngredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientStorePartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStorePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>>
    export type IngredientStorePartialUpdateMutationBody = NonReadonly<PatchedOnHandIngredient>
    export type IngredientStorePartialUpdateMutationError = AxiosError<unknown>

    export const useIngredientStorePartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStorePartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedOnHandIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStorePartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedOnHandIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientStorePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientStoreDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/ingredient-store/${id}/`,options
    );
  }



export const getIngredientStoreDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['ingredientStoreDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientStoreDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  ingredientStoreDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientStoreDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientStoreDestroy>>>
    
    export type IngredientStoreDestroyMutationError = AxiosError<unknown>

    export const useIngredientStoreDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientStoreDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientStoreDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getIngredientStoreDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsList = (
    params?: IngredientsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedIngredientList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredients/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getIngredientsListQueryKey = (params?: IngredientsListParams,) => {
    return [
    `http://localhost:8000/api/ingredients/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getIngredientsListQueryOptions = <TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientsList>>> = ({ signal }) => ingredientsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientsListQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientsList>>>
export type IngredientsListQueryError = AxiosError<unknown>


export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params: undefined |  IngredientsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsList>>,
          TError,
          Awaited<ReturnType<typeof ingredientsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsList>>,
          TError,
          Awaited<ReturnType<typeof ingredientsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientsCreate = (
    ingredient: NonReadonly<Ingredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/ingredients/`,
      ingredient,options
    );
  }



export const getIngredientsCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext> => {

const mutationKey = ['ingredientsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsCreate>>, {data: NonReadonly<Ingredient>}> = (props) => {
          const {data} = props ?? {};

          return  ingredientsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsCreate>>>
    export type IngredientsCreateMutationBody = NonReadonly<Ingredient>
    export type IngredientsCreateMutationError = AxiosError<unknown>

    export const useIngredientsCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsCreate>>,
        TError,
        {data: NonReadonly<Ingredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredients/${id}/`,options
    );
  }




export const getIngredientsRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/ingredients/${id}/`
    ] as const;
    }

    
export const getIngredientsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientsRetrieve>>> = ({ signal }) => ingredientsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientsRetrieve>>>
export type IngredientsRetrieveQueryError = AxiosError<unknown>


export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientsUpdate = (
    id: number,
    ingredient: NonReadonly<Ingredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/ingredients/${id}/`,
      ingredient,options
    );
  }



export const getIngredientsUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext> => {

const mutationKey = ['ingredientsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsUpdate>>, {id: number;data: NonReadonly<Ingredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsUpdate>>>
    export type IngredientsUpdateMutationBody = NonReadonly<Ingredient>
    export type IngredientsUpdateMutationError = AxiosError<unknown>

    export const useIngredientsUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Ingredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsPartialUpdate = (
    id: number,
    patchedIngredient: NonReadonly<PatchedIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/ingredients/${id}/`,
      patchedIngredient,options
    );
  }



export const getIngredientsPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext> => {

const mutationKey = ['ingredientsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, {id: number;data: NonReadonly<PatchedIngredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsPartialUpdate>>>
    export type IngredientsPartialUpdateMutationBody = NonReadonly<PatchedIngredient>
    export type IngredientsPartialUpdateMutationError = AxiosError<unknown>

    export const useIngredientsPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/ingredients/${id}/`,options
    );
  }



export const getIngredientsDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['ingredientsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  ingredientsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsDestroy>>>
    
    export type IngredientsDestroyMutationError = AxiosError<unknown>

    export const useIngredientsDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getIngredientsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesList = (
    params?: RecipesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedRecipeList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/recipes/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getRecipesListQueryKey = (params?: RecipesListParams,) => {
    return [
    `http://localhost:8000/api/recipes/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getRecipesListQueryOptions = <TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRecipesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof recipesList>>> = ({ signal }) => recipesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecipesListQueryResult = NonNullable<Awaited<ReturnType<typeof recipesList>>>
export type RecipesListQueryError = AxiosError<unknown>


export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params: undefined |  RecipesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesList>>,
          TError,
          Awaited<ReturnType<typeof recipesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesList>>,
          TError,
          Awaited<ReturnType<typeof recipesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRecipesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const recipesCreate = (
    recipe: NonReadonly<Recipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/recipes/`,
      recipe,options
    );
  }



export const getRecipesCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext> => {

const mutationKey = ['recipesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesCreate>>, {data: NonReadonly<Recipe>}> = (props) => {
          const {data} = props ?? {};

          return  recipesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesCreate>>>
    export type RecipesCreateMutationBody = NonReadonly<Recipe>
    export type RecipesCreateMutationError = AxiosError<unknown>

    export const useRecipesCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesCreate>>,
        TError,
        {data: NonReadonly<Recipe>},
        TContext
      > => {

      const mutationOptions = getRecipesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/recipes/${id}/`,options
    );
  }




export const getRecipesRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/recipes/${id}/`
    ] as const;
    }

    
export const getRecipesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRecipesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof recipesRetrieve>>> = ({ signal }) => recipesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecipesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof recipesRetrieve>>>
export type RecipesRetrieveQueryError = AxiosError<unknown>


export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof recipesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof recipesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRecipesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const recipesUpdate = (
    id: number,
    recipe: NonReadonly<Recipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/recipes/${id}/`,
      recipe,options
    );
  }



export const getRecipesUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext> => {

const mutationKey = ['recipesUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesUpdate>>, {id: number;data: NonReadonly<Recipe>}> = (props) => {
          const {id,data} = props ?? {};

          return  recipesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesUpdate>>>
    export type RecipesUpdateMutationBody = NonReadonly<Recipe>
    export type RecipesUpdateMutationError = AxiosError<unknown>

    export const useRecipesUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesUpdate>>,
        TError,
        {id: number;data: NonReadonly<Recipe>},
        TContext
      > => {

      const mutationOptions = getRecipesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesPartialUpdate = (
    id: number,
    patchedRecipe: NonReadonly<PatchedRecipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/recipes/${id}/`,
      patchedRecipe,options
    );
  }



export const getRecipesPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext> => {

const mutationKey = ['recipesPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesPartialUpdate>>, {id: number;data: NonReadonly<PatchedRecipe>}> = (props) => {
          const {id,data} = props ?? {};

          return  recipesPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesPartialUpdate>>>
    export type RecipesPartialUpdateMutationBody = NonReadonly<PatchedRecipe>
    export type RecipesPartialUpdateMutationError = AxiosError<unknown>

    export const useRecipesPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedRecipe>},
        TContext
      > => {

      const mutationOptions = getRecipesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/recipes/${id}/`,options
    );
  }



export const getRecipesDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['recipesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  recipesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof recipesDestroy>>>
    
    export type RecipesDestroyMutationError = AxiosError<unknown>

    export const useRecipesDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getRecipesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsList = (
    params?: TagsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedTagList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/tags/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getTagsListQueryKey = (params?: TagsListParams,) => {
    return [
    `http://localhost:8000/api/tags/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getTagsListQueryOptions = <TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsList>>> = ({ signal }) => tagsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TagsListQueryResult = NonNullable<Awaited<ReturnType<typeof tagsList>>>
export type TagsListQueryError = AxiosError<unknown>


export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params: undefined |  TagsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsList>>,
          TError,
          Awaited<ReturnType<typeof tagsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsList>>,
          TError,
          Awaited<ReturnType<typeof tagsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTagsList<TData = Awaited<ReturnType<typeof tagsList>>, TError = AxiosError<unknown>>(
 params?: TagsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTagsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagsCreate = (
    tag: NonReadonly<Tag>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/tags/`,
      tag,options
    );
  }



export const getTagsCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext> => {

const mutationKey = ['tagsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsCreate>>, {data: NonReadonly<Tag>}> = (props) => {
          const {data} = props ?? {};

          return  tagsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsCreate>>>
    export type TagsCreateMutationBody = NonReadonly<Tag>
    export type TagsCreateMutationError = AxiosError<unknown>

    export const useTagsCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsCreate>>, TError,{data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsCreate>>,
        TError,
        {data: NonReadonly<Tag>},
        TContext
      > => {

      const mutationOptions = getTagsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/tags/${id}/`,options
    );
  }




export const getTagsRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/tags/${id}/`
    ] as const;
    }

    
export const getTagsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTagsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof tagsRetrieve>>> = ({ signal }) => tagsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TagsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof tagsRetrieve>>>
export type TagsRetrieveQueryError = AxiosError<unknown>


export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tagsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tagsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof tagsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useTagsRetrieve<TData = Awaited<ReturnType<typeof tagsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof tagsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTagsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const tagsUpdate = (
    id: number,
    tag: NonReadonly<Tag>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/tags/${id}/`,
      tag,options
    );
  }



export const getTagsUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: number;data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: number;data: NonReadonly<Tag>}, TContext> => {

const mutationKey = ['tagsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsUpdate>>, {id: number;data: NonReadonly<Tag>}> = (props) => {
          const {id,data} = props ?? {};

          return  tagsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsUpdate>>>
    export type TagsUpdateMutationBody = NonReadonly<Tag>
    export type TagsUpdateMutationError = AxiosError<unknown>

    export const useTagsUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsUpdate>>, TError,{id: number;data: NonReadonly<Tag>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Tag>},
        TContext
      > => {

      const mutationOptions = getTagsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsPartialUpdate = (
    id: number,
    patchedTag: NonReadonly<PatchedTag>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Tag>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/tags/${id}/`,
      patchedTag,options
    );
  }



export const getTagsPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTag>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTag>}, TContext> => {

const mutationKey = ['tagsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsPartialUpdate>>, {id: number;data: NonReadonly<PatchedTag>}> = (props) => {
          const {id,data} = props ?? {};

          return  tagsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof tagsPartialUpdate>>>
    export type TagsPartialUpdateMutationBody = NonReadonly<PatchedTag>
    export type TagsPartialUpdateMutationError = AxiosError<unknown>

    export const useTagsPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTag>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedTag>},
        TContext
      > => {

      const mutationOptions = getTagsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const tagsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/tags/${id}/`,options
    );
  }



export const getTagsDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['tagsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tagsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  tagsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TagsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof tagsDestroy>>>
    
    export type TagsDestroyMutationError = AxiosError<unknown>

    export const useTagsDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tagsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tagsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getTagsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
