/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Mealmode API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * * `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count
 */
export type BaseUnitEnum = typeof BaseUnitEnum[keyof typeof BaseUnitEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BaseUnitEnum = {
  kg: 'kg',
  L: 'L',
  pc: 'pc',
} as const;

export interface Ingredient {
  readonly id: number;
  /** @maxLength 100 */
  name: string;
  readonly nutrition_stats: NutritionStats;
  /**
   * Lowest known cost per base unit (e.g., $/kg
   * @nullable
   */
  lowest_cost?: number | null;
}

export interface NutritionStats {
  readonly id: number;
  /** The base unit for the nutrition stats (e.g., per kg, per liter, etc.)

* `kg` - Kilogram
* `L` - Liter
* `pc` - Piece / Count */
  base_unit?: BaseUnitEnum;
  /**
   * Calories (Kcal) per base unit
   * @nullable
   */
  kcal_per_unit?: number | null;
  /**
   * Saturated fat (g) per base unit
   * @nullable
   */
  fat_saturated_grams_per_unit?: number | null;
  /**
   * Trans fat (g) per base unit
   * @nullable
   */
  fat_trans_grams_per_unit?: number | null;
  /**
   * Fiber (g) per base unit
   * @nullable
   */
  carbohydrate_fiber_grams_per_unit?: number | null;
  /**
   * Sugars (g) per base unit
   * @nullable
   */
  carbohydrate_sugar_grams_per_unit?: number | null;
  /**
   * Protein (g) per base unit
   * @nullable
   */
  protein_grams_per_unit?: number | null;
  /**
   * Cholesterol (mg) per base unit
   * @nullable
   */
  cholesterol_milligrams_per_unit?: number | null;
  /**
   * Sodium (mg) per base unit
   * @nullable
   */
  sodium_milligrams_per_unit?: number | null;
  /**
   * Potassium (mg) per base unit
   * @nullable
   */
  potassium_milligrams_per_unit?: number | null;
  /**
   * Calcium (mg) per base unit
   * @nullable
   */
  calcium_milligrams_per_unit?: number | null;
  /**
   * Iron (mg) per base unit
   * @nullable
   */
  iron_milligrams_per_unit?: number | null;
  /**
   * Vitamin A (mg) per base unit
   * @nullable
   */
  vitamin_a_milligrams_per_unit?: number | null;
  /**
   * Vitamin C (mg) per base unit
   * @nullable
   */
  vitamin_c_milligrams_per_unit?: number | null;
  /**
   * Vitamin D (mg) per base unit
   * @nullable
   */
  vitamin_d_milligrams_per_unit?: number | null;
  /** @nullable */
  ingredient?: number | null;
}

export interface PaginatedIngredientList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Ingredient[];
}

export interface PaginatedRecipeList {
  count: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results: Recipe[];
}

export interface PatchedIngredient {
  readonly id?: number;
  /** @maxLength 100 */
  name?: string;
  readonly nutrition_stats?: NutritionStats;
  /**
   * Lowest known cost per base unit (e.g., $/kg
   * @nullable
   */
  lowest_cost?: number | null;
}

export interface PatchedRecipe {
  readonly id?: number;
  readonly ingredients_list?: readonly RecipeIngredient[];
  /** @maxLength 100 */
  name?: string;
  /**
   * Number of servings this recipe makes
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  servings?: number;
  readonly ingredients?: readonly number[];
}

export interface Recipe {
  readonly id: number;
  readonly ingredients_list: readonly RecipeIngredient[];
  /** @maxLength 100 */
  name: string;
  /**
   * Number of servings this recipe makes
   * @minimum -9223372036854776000
   * @maximum 9223372036854776000
   */
  servings?: number;
  readonly ingredients: readonly number[];
}

export interface RecipeIngredient {
  readonly id: number;
  readonly ingredient: Ingredient;
  /** Quantity in base units (e.g., grams, liters, pieces), defined by the ingredient's nutrition stats) */
  quantity: number;
}

export type IngredientsListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export type RecipesListParams = {
/**
 * Number of results to return per page.
 */
limit?: number;
/**
 * The initial index from which to return the results.
 */
offset?: number;
};

export const ingredientsList = (
    params?: IngredientsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedIngredientList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredients/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getIngredientsListQueryKey = (params?: IngredientsListParams,) => {
    return [
    `http://localhost:8000/api/ingredients/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getIngredientsListQueryOptions = <TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientsList>>> = ({ signal }) => ingredientsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientsListQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientsList>>>
export type IngredientsListQueryError = AxiosError<unknown>


export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params: undefined |  IngredientsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsList>>,
          TError,
          Awaited<ReturnType<typeof ingredientsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsList>>,
          TError,
          Awaited<ReturnType<typeof ingredientsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientsList<TData = Awaited<ReturnType<typeof ingredientsList>>, TError = AxiosError<unknown>>(
 params?: IngredientsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientsCreate = (
    ingredient: NonReadonly<Ingredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/ingredients/`,
      ingredient,options
    );
  }



export const getIngredientsCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext> => {

const mutationKey = ['ingredientsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsCreate>>, {data: NonReadonly<Ingredient>}> = (props) => {
          const {data} = props ?? {};

          return  ingredientsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsCreate>>>
    export type IngredientsCreateMutationBody = NonReadonly<Ingredient>
    export type IngredientsCreateMutationError = AxiosError<unknown>

    export const useIngredientsCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsCreate>>, TError,{data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsCreate>>,
        TError,
        {data: NonReadonly<Ingredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/ingredients/${id}/`,options
    );
  }




export const getIngredientsRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/ingredients/${id}/`
    ] as const;
    }

    
export const getIngredientsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIngredientsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ingredientsRetrieve>>> = ({ signal }) => ingredientsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IngredientsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof ingredientsRetrieve>>>
export type IngredientsRetrieveQueryError = AxiosError<unknown>


export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof ingredientsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof ingredientsRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useIngredientsRetrieve<TData = Awaited<ReturnType<typeof ingredientsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof ingredientsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIngredientsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const ingredientsUpdate = (
    id: number,
    ingredient: NonReadonly<Ingredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/ingredients/${id}/`,
      ingredient,options
    );
  }



export const getIngredientsUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext> => {

const mutationKey = ['ingredientsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsUpdate>>, {id: number;data: NonReadonly<Ingredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsUpdate>>>
    export type IngredientsUpdateMutationBody = NonReadonly<Ingredient>
    export type IngredientsUpdateMutationError = AxiosError<unknown>

    export const useIngredientsUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsUpdate>>, TError,{id: number;data: NonReadonly<Ingredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Ingredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsPartialUpdate = (
    id: number,
    patchedIngredient: NonReadonly<PatchedIngredient>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Ingredient>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/ingredients/${id}/`,
      patchedIngredient,options
    );
  }



export const getIngredientsPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext> => {

const mutationKey = ['ingredientsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, {id: number;data: NonReadonly<PatchedIngredient>}> = (props) => {
          const {id,data} = props ?? {};

          return  ingredientsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsPartialUpdate>>>
    export type IngredientsPartialUpdateMutationBody = NonReadonly<PatchedIngredient>
    export type IngredientsPartialUpdateMutationError = AxiosError<unknown>

    export const useIngredientsPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedIngredient>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedIngredient>},
        TContext
      > => {

      const mutationOptions = getIngredientsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const ingredientsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/ingredients/${id}/`,options
    );
  }



export const getIngredientsDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['ingredientsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ingredientsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  ingredientsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type IngredientsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof ingredientsDestroy>>>
    
    export type IngredientsDestroyMutationError = AxiosError<unknown>

    export const useIngredientsDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ingredientsDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof ingredientsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getIngredientsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesList = (
    params?: RecipesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedRecipeList>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/recipes/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getRecipesListQueryKey = (params?: RecipesListParams,) => {
    return [
    `http://localhost:8000/api/recipes/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getRecipesListQueryOptions = <TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRecipesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof recipesList>>> = ({ signal }) => recipesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecipesListQueryResult = NonNullable<Awaited<ReturnType<typeof recipesList>>>
export type RecipesListQueryError = AxiosError<unknown>


export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params: undefined |  RecipesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesList>>,
          TError,
          Awaited<ReturnType<typeof recipesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesList>>,
          TError,
          Awaited<ReturnType<typeof recipesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecipesList<TData = Awaited<ReturnType<typeof recipesList>>, TError = AxiosError<unknown>>(
 params?: RecipesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRecipesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const recipesCreate = (
    recipe: NonReadonly<Recipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.post(
      `http://localhost:8000/api/recipes/`,
      recipe,options
    );
  }



export const getRecipesCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext> => {

const mutationKey = ['recipesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesCreate>>, {data: NonReadonly<Recipe>}> = (props) => {
          const {data} = props ?? {};

          return  recipesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesCreate>>>
    export type RecipesCreateMutationBody = NonReadonly<Recipe>
    export type RecipesCreateMutationError = AxiosError<unknown>

    export const useRecipesCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesCreate>>, TError,{data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesCreate>>,
        TError,
        {data: NonReadonly<Recipe>},
        TContext
      > => {

      const mutationOptions = getRecipesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.get(
      `http://localhost:8000/api/recipes/${id}/`,options
    );
  }




export const getRecipesRetrieveQueryKey = (id?: number,) => {
    return [
    `http://localhost:8000/api/recipes/${id}/`
    ] as const;
    }

    
export const getRecipesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRecipesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof recipesRetrieve>>> = ({ signal }) => recipesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RecipesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof recipesRetrieve>>>
export type RecipesRetrieveQueryError = AxiosError<unknown>


export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof recipesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof recipesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof recipesRetrieve>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useRecipesRetrieve<TData = Awaited<ReturnType<typeof recipesRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof recipesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRecipesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const recipesUpdate = (
    id: number,
    recipe: NonReadonly<Recipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.put(
      `http://localhost:8000/api/recipes/${id}/`,
      recipe,options
    );
  }



export const getRecipesUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext> => {

const mutationKey = ['recipesUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesUpdate>>, {id: number;data: NonReadonly<Recipe>}> = (props) => {
          const {id,data} = props ?? {};

          return  recipesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesUpdate>>>
    export type RecipesUpdateMutationBody = NonReadonly<Recipe>
    export type RecipesUpdateMutationError = AxiosError<unknown>

    export const useRecipesUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesUpdate>>, TError,{id: number;data: NonReadonly<Recipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesUpdate>>,
        TError,
        {id: number;data: NonReadonly<Recipe>},
        TContext
      > => {

      const mutationOptions = getRecipesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesPartialUpdate = (
    id: number,
    patchedRecipe: NonReadonly<PatchedRecipe>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Recipe>> => {
    
    
    return axios.default.patch(
      `http://localhost:8000/api/recipes/${id}/`,
      patchedRecipe,options
    );
  }



export const getRecipesPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext> => {

const mutationKey = ['recipesPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesPartialUpdate>>, {id: number;data: NonReadonly<PatchedRecipe>}> = (props) => {
          const {id,data} = props ?? {};

          return  recipesPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof recipesPartialUpdate>>>
    export type RecipesPartialUpdateMutationBody = NonReadonly<PatchedRecipe>
    export type RecipesPartialUpdateMutationError = AxiosError<unknown>

    export const useRecipesPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedRecipe>}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedRecipe>},
        TContext
      > => {

      const mutationOptions = getRecipesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const recipesDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `http://localhost:8000/api/recipes/${id}/`,options
    );
  }



export const getRecipesDestroyMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['recipesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recipesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  recipesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecipesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof recipesDestroy>>>
    
    export type RecipesDestroyMutationError = AxiosError<unknown>

    export const useRecipesDestroy = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recipesDestroy>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof recipesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getRecipesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
